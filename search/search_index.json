{"config":{"lang":["en"],"separator":"[\\s\\-]+","pipeline":["stopWordFilter"],"fields":{"title":{"boost":1000.0},"text":{"boost":1.0},"tags":{"boost":1000000.0}}},"docs":[{"location":"","title":"STAC Generator","text":"<p>The STAC Generator provides a framework that leverages a modular, plugin architecture to allow users to configure a workflow to generate, extract, and manipulate metadata to fit their requirement's needs.</p> <p>The framework was constructed to extract metadata for STAC catalogs but could be used to extract metadata for any number of systems.</p>"},{"location":"#how-the-generator-works","title":"How the Generator works?","text":"<p>Input plugins can be configured to produce a series of \"events\". For each event the relevant recipe is found and it's extraction methods are ran to produce a metadata record. This record can then be mapped to a desired format,  such as STAC, using mapping plugins and then output to one or more output plugins.</p>"},{"location":"#how-to-configure-the-generator","title":"How to configure the Generator?","text":"<p>Generator configutation is spread across two levels. The main configuration defines which Inputs are to be run, if the data needs to be mapped, where the  generated data should be output to, and the location of the other configuration. The second level of configuration, known as recipes, define which extraction methods should be run for each event. Having this second level allows different extraction methods to be run on different events to produce more specific metadata.</p>"},{"location":"#what-is-stac","title":"What is STAC?","text":"<p>The SpatioTemporal Asset Catalog (STAC) specification provides a common language to describe a range of geospatial information, so it can more easily be indexed and discovered. A \"spatiotemporal asset\" is any file that represents information about the earth captured in a certain space and time.</p>"},{"location":"generator_config/","title":"Generator Configuration","text":"<p>Generators consit of 4 components:</p> Key Type Description generator str Type of generator to be run. recipe_root str The root directory of the recipes. inputs list[Inputs] Inputs to collect initial data. outputs list[Outputs | Bulk Outputs] Ouputs to post produced data to. <p>Example:</p> <pre><code>generator: item\n\nrecipes_root: recipes/\n\ninputs:\n  - name: text_file\n    conf:\n      filepath: input/assets.txt\n\noutputs:\n  - name: standard_out\n    mappings:\n      - name: stac\n        stac_version: '1.0.0'\n        stac_extensions: []\n</code></pre>"},{"location":"inputs/","title":"Inputs","text":"<p>The input plugins generate a stream of dictionaries to be passed to the generator for processing.</p> <p>You can configure more than one input plugin, if you wanted to input the content from more than one place.</p> <p>Inputs are loaded as named entry points with the namespace: <code>stac_generator.inputs</code></p> <p>.. warning::     Blocking input plugins will prevent others from being run. They are run     sequentially. For example, with the :ref:<code>file system input plugin &lt;stac_generator/inputs:File System Input&gt;</code>, you     could configure several to scan multiple directories but the rabbit plugin     creates a listening connection which would block any other inputs.</p> Example Configuration <p>.. code-block:: yaml</p> <pre><code>inputs:\n  - name: text_file\n    conf:\n      path: ../manifests/cmip6.txt\n</code></pre>"},{"location":"mappings/","title":"Mappings","text":"<p>The mappings are run before an output and map the data into the desired format.</p> <p>You can configure more than one mapping per output. Mappings run in the order they are given.</p> <p>Mappings are loaded as named entry points with the namespace: <code>stac_generator.mappings</code></p> Example Configuration <p>.. code-block:: yaml</p> <pre><code>mappings:\n  - name: jinja2_mapping\n    conf:\n      template_directory: /path/to/template/directory\n      template: template_name\n</code></pre>"},{"location":"outputs/","title":"Outputs","text":"<p>The outputs determine what happens at the end of the extraction process.</p> <p>You can configure more than one active plugin, if you wanted to output the content to more than one place.</p> <p>Outputs are loaded as named entry points with the namespace: <code>stac_generator.outputs</code></p> Example Configuration <p>.. code-block:: yaml</p> <pre><code>outputs:\n  - name: json_out\n    conf:\n      dirpath: location_to_destination_file\n      filename_term: item_id\n</code></pre> <p>The outputs determine what happens at the end of the extraction process.</p> <p>Bulk outputs store collect a configured number of message before outputting and output any remaining message after the input has finished.</p> <p>You can configure more than one active plugin, if you wanted to output the content to more than one place.</p> <p>Bulk Outputs are loaded with standard outputs as named entry points with the namespace: <code>stac_generator.outputs</code></p> Example Configuration <p>.. code-block:: yaml</p> <pre><code>outputs:\n    - name: elasticsearch_bulk\n      conf:\n        client_kwargs:\n          hosts: ['host1','host2']\n          index:\n            name: 'assets-2021-06-02'\n</code></pre>"},{"location":"recipes/","title":"Recipes","text":"<p>Recipes describe how metadata should be extracted and manipulated for an event.</p>"},{"location":"recipes/#recipe-sections","title":"Recipe sections","text":"<p>The description file consists of 3 top level keys:</p> <p>A Full JSON Schema references below.</p> Key Type Description paths list[str] Paths the recipe applies to. type str The type of generator. Can be used to group recipes. extraction_methods list[Extraction Methods] The extraction methods to generate the metadata."},{"location":"recipes/#paths","title":"Paths","text":"<p>Defines the set of paths which the recipe is applicable to. When multiple recipes match a record the most specific will be chosen.</p> <pre><code>paths:\n  - /badc/faam/data\n</code></pre>"},{"location":"recipes/#type","title":"Type","text":"<p>Defines the type of record that will be produced. This allow recipes to be grouped.</p> <pre><code>type: item\n</code></pre>"},{"location":"recipes/#extraction-methods","title":"Extraction Methods","text":"<p>Defines a list of extraction methods used to generate the record's metadata.</p> <pre><code>extraction_methods:\n  - method: lambda\n    inputs:\n      function: 'lambda uri: uri.replace(\"/badc/cmip6/data\", \"\").strip(\"/\").replace(\"/\", \".\")'\n      args:\n        - $uri\n      output_key: instance_id\n</code></pre>"},{"location":"recipes/#schema","title":"Schema","text":"<p>.. program-output:: python -c \"from stac_generator.core.baker import Recipe; import json; print(json.dumps(Recipe.schema(), indent=4))\"</p>"},{"location":"bulk_outputs/elasticsearch/","title":"Elasticsearch","text":""},{"location":"bulk_outputs/elasticsearch/#stac_generator.plugins.bulk_outputs.elasticsearch.ElasticsearchBulkOutput","title":"<code>ElasticsearchBulkOutput</code>","text":"<p>               Bases: <code>BulkOutput</code></p> <p>Outputs to elasticsearch.</p> <p>Plugin name: <code>elasticsearch_bulk</code></p> Example Configuration <p>.. code-block:: yaml</p> <pre><code>- name: elasticsearch_bulk\n  conf:\n    client_kwargs:\n      hosts: ['host1','host2']\n      index:\n        name: 'assets-2021-06-02'\n</code></pre> Source code in <code>stac_generator/plugins/bulk_outputs/elasticsearch.py</code> <pre><code>class ElasticsearchBulkOutput(BulkOutput):\n    \"\"\"\n    Outputs to elasticsearch.\n\n    **Plugin name:** ``elasticsearch_bulk``\n\n    Example Configuration:\n        .. code-block:: yaml\n\n            - name: elasticsearch_bulk\n              conf:\n                client_kwargs:\n                  hosts: ['host1','host2']\n                  index:\n                    name: 'assets-2021-06-02'\n\n    \"\"\"\n\n    config_class = ElasticsearchConf\n\n    def __init__(self, **kwargs):\n        super().__init__(**kwargs)\n\n        self.es = Elasticsearch(**self.conf.client_kwargs)\n\n        # Create the index, if it doesn't already exist\n        if mapping := self.conf.index.mapping:\n            if not self.es.indices.exists(self.conf.index.name):\n                if isinstance(mapping, str):\n                    mapping = load_yaml(mapping)\n                self.es.indices.create(self.conf.index.name, body=mapping)\n\n    def action_iterator(self, data_list: list) -&gt; Iterator[dict]:\n        \"\"\"\n        Generate an iterator of elasticsearch actions.\n\n        :param data_list: List of output data\n\n        :returns: elasticsearch action\n        \"\"\"\n        for data in data_list:\n\n            yield {\n                \"_op_type\": \"update\",\n                \"_index\": self.conf.index.name,\n                \"_id\": data[\"id\"],\n                \"doc\": data[\"body\"],\n                \"doc_as_upsert\": True,\n            }\n\n    def export(self, data_list: list) -&gt; None:\n        \"\"\"\n        Export using elasticsearch bulk helper.\n        \"\"\"\n        for okay, info in streaming_bulk(self.es, self.action_iterator(data_list), yield_ok=False):\n            if not okay:\n                LOGGER.error(\n                    \"Unable to index %s: %s\",\n                    info[\"update\"][\"_id\"],\n                    info[\"update\"][\"error\"],\n                )\n</code></pre>"},{"location":"bulk_outputs/elasticsearch/#stac_generator.plugins.bulk_outputs.elasticsearch.ElasticsearchBulkOutput.action_iterator","title":"<code>action_iterator(data_list)</code>","text":"<p>Generate an iterator of elasticsearch actions.</p> <p>:param data_list: List of output data</p> <p>:returns: elasticsearch action</p> Source code in <code>stac_generator/plugins/bulk_outputs/elasticsearch.py</code> <pre><code>def action_iterator(self, data_list: list) -&gt; Iterator[dict]:\n    \"\"\"\n    Generate an iterator of elasticsearch actions.\n\n    :param data_list: List of output data\n\n    :returns: elasticsearch action\n    \"\"\"\n    for data in data_list:\n\n        yield {\n            \"_op_type\": \"update\",\n            \"_index\": self.conf.index.name,\n            \"_id\": data[\"id\"],\n            \"doc\": data[\"body\"],\n            \"doc_as_upsert\": True,\n        }\n</code></pre>"},{"location":"bulk_outputs/elasticsearch/#stac_generator.plugins.bulk_outputs.elasticsearch.ElasticsearchBulkOutput.export","title":"<code>export(data_list)</code>","text":"<p>Export using elasticsearch bulk helper.</p> Source code in <code>stac_generator/plugins/bulk_outputs/elasticsearch.py</code> <pre><code>def export(self, data_list: list) -&gt; None:\n    \"\"\"\n    Export using elasticsearch bulk helper.\n    \"\"\"\n    for okay, info in streaming_bulk(self.es, self.action_iterator(data_list), yield_ok=False):\n        if not okay:\n            LOGGER.error(\n                \"Unable to index %s: %s\",\n                info[\"update\"][\"_id\"],\n                info[\"update\"][\"error\"],\n            )\n</code></pre>"},{"location":"bulk_outputs/elasticsearch/#stac_generator.plugins.bulk_outputs.elasticsearch.ElasticsearchConf","title":"<code>ElasticsearchConf</code>","text":"<p>               Bases: <code>BulkOutputConf</code></p> <p>Elasticsearch config model.</p> Source code in <code>stac_generator/plugins/bulk_outputs/elasticsearch.py</code> <pre><code>class ElasticsearchConf(BulkOutputConf):\n    \"\"\"Elasticsearch config model.\"\"\"\n\n    index: ElasticsearchIndex = Field(\n        description=\"Elasticsearch index to post to.\",\n    )\n    client_kwargs: dict = Field(\n        default={},\n        description=\"Elasticsearch connection kwargs.\",\n    )\n    request_timeout: int = Field(\n        default=60,\n        description=\"Request timeout for search.\",\n    )\n</code></pre>"},{"location":"bulk_outputs/elasticsearch/#stac_generator.plugins.bulk_outputs.elasticsearch.ElasticsearchIndex","title":"<code>ElasticsearchIndex</code>","text":"<p>               Bases: <code>BaseModel</code></p> <p>Elasticsearch index model.</p> Source code in <code>stac_generator/plugins/bulk_outputs/elasticsearch.py</code> <pre><code>class ElasticsearchIndex(BaseModel):\n    \"\"\"Elasticsearch index model.\"\"\"\n\n    name: str = Field(\n        description=\"Name of index.\",\n    )\n    mapping: str | dict = Field(\n        default={},\n        description=\"Index initial mapping.\",\n    )\n</code></pre>"},{"location":"bulk_outputs/rabbit_mq/","title":"Rabbit mq","text":""},{"location":"bulk_outputs/rabbit_mq/#stac_generator.plugins.bulk_outputs.rabbit_mq.RabbitMQBulkOutput","title":"<code>RabbitMQBulkOutput</code>","text":"<p>               Bases: <code>BulkOutput</code></p> <p>Uses a <code>RabbitMQ Queue &lt;https://www.rabbitmq.com/&gt;</code>_ as a destination for parent generation messages.</p> <p>Plugin name: <code>rabbitmq_out_bulk</code></p> Example Configuration <p>.. code-block:: yaml</p> <pre><code>- name: rabbitmq_bulk\n  conf:\n    connection:\n      host: my-rabbit-server.co.uk\n      user: user\n      password: '*********'\n      vhost: my_virtual_host\n      kwargs:\n        heartbeat: 300\n    exchange:\n      name: mydest-exchange\n      type: fanout\n      routing_key: asset\n    cache_max_size: 10\n</code></pre> Source code in <code>stac_generator/plugins/bulk_outputs/rabbit_mq.py</code> <pre><code>class RabbitMQBulkOutput(BulkOutput):\n    \"\"\"\n    Uses a `RabbitMQ Queue &lt;https://www.rabbitmq.com/&gt;`_ as a destination for parent\n    generation messages.\n\n    **Plugin name:** ``rabbitmq_out_bulk``\n\n    Example Configuration:\n        .. code-block:: yaml\n\n            - name: rabbitmq_bulk\n              conf:\n                connection:\n                  host: my-rabbit-server.co.uk\n                  user: user\n                  password: '*********'\n                  vhost: my_virtual_host\n                  kwargs:\n                    heartbeat: 300\n                exchange:\n                  name: mydest-exchange\n                  type: fanout\n                  routing_key: asset\n                cache_max_size: 10\n    \"\"\"\n\n    config_class = RabbitMQConf\n\n    def __init__(self, **kwargs):\n        super().__init__(**kwargs)\n\n        # Create the credentials object\n        credentials = pika.PlainCredentials(\n            self.conf.connection.user, self.conf.connection.password\n        )\n\n        # Start the rabbitMQ connection\n        rabbit_connection = pika.BlockingConnection(\n            pika.ConnectionParameters(\n                host=self.conf.connection.host,\n                credentials=credentials,\n                virtual_host=self.conf.connection.vhost,\n                **self.conf.connection.kwargs,\n            )\n        )\n\n        # Create a new channel\n        self.channel = rabbit_connection.channel()\n        self.channel.exchange_declare(\n            exchange=self.conf.exchange.name,\n            exchange_type=self.conf.exchange.type,\n        )\n\n    def data_to_cache(self, data: dict) -&gt; None:\n        \"\"\"\n        Convert the data into a data to  be stored in cache.\n\n        :param data: data from processor to be output.\n        :param kwargs:\n        \"\"\"\n        return {\n            data[\"body\"][f\"{data['surtype']}_id\"]: {\n                f\"{data['surtype']}_id\": data[\"body\"][f\"{data['surtype']}_id\"],\n                \"uri\": data[\"uri\"],\n            }\n        }\n\n    def export(self, data_list: list) -&gt; None:\n        \"\"\"\n        Export the data to rabbit.\n\n        :param data: expected data as header dict\n        \"\"\"\n\n        self.channel.basic_publish(\n            exchange=self.conf.exchange.name,\n            body=json.dumps(data_list),\n            routing_key=self.conf.exchange.routing_key,\n        )\n</code></pre>"},{"location":"bulk_outputs/rabbit_mq/#stac_generator.plugins.bulk_outputs.rabbit_mq.RabbitMQBulkOutput.data_to_cache","title":"<code>data_to_cache(data)</code>","text":"<p>Convert the data into a data to  be stored in cache.</p> <p>:param data: data from processor to be output. :param kwargs:</p> Source code in <code>stac_generator/plugins/bulk_outputs/rabbit_mq.py</code> <pre><code>def data_to_cache(self, data: dict) -&gt; None:\n    \"\"\"\n    Convert the data into a data to  be stored in cache.\n\n    :param data: data from processor to be output.\n    :param kwargs:\n    \"\"\"\n    return {\n        data[\"body\"][f\"{data['surtype']}_id\"]: {\n            f\"{data['surtype']}_id\": data[\"body\"][f\"{data['surtype']}_id\"],\n            \"uri\": data[\"uri\"],\n        }\n    }\n</code></pre>"},{"location":"bulk_outputs/rabbit_mq/#stac_generator.plugins.bulk_outputs.rabbit_mq.RabbitMQBulkOutput.export","title":"<code>export(data_list)</code>","text":"<p>Export the data to rabbit.</p> <p>:param data: expected data as header dict</p> Source code in <code>stac_generator/plugins/bulk_outputs/rabbit_mq.py</code> <pre><code>def export(self, data_list: list) -&gt; None:\n    \"\"\"\n    Export the data to rabbit.\n\n    :param data: expected data as header dict\n    \"\"\"\n\n    self.channel.basic_publish(\n        exchange=self.conf.exchange.name,\n        body=json.dumps(data_list),\n        routing_key=self.conf.exchange.routing_key,\n    )\n</code></pre>"},{"location":"bulk_outputs/rabbit_mq/#stac_generator.plugins.bulk_outputs.rabbit_mq.RabbitMQConf","title":"<code>RabbitMQConf</code>","text":"<p>               Bases: <code>BulkOutputConf</code></p> <p>RabbitMQ config model.</p> <p>Parameters:</p> Name Type Description Default <code>connection</code> <code>RabbitMQConnection</code> <p>RabbitMQ connection kwargs.</p> <code>{}</code> <code>exchange</code> <code>RabbitMQExchange</code> <p>RabbitMQ exchange info.</p> required Source code in <code>stac_generator/plugins/bulk_outputs/rabbit_mq.py</code> <pre><code>class RabbitMQConf(BulkOutputConf):\n    \"\"\"RabbitMQ config model.\"\"\"\n\n    connection: RabbitMQConnection = Field(\n        default={},\n        description=\"RabbitMQ connection kwargs.\",\n    )\n    exchange: RabbitMQExchange = Field(\n        description=\"RabbitMQ exchange info.\",\n    )\n</code></pre>"},{"location":"bulk_outputs/rabbit_mq/#stac_generator.plugins.bulk_outputs.rabbit_mq.RabbitMQConnection","title":"<code>RabbitMQConnection</code>","text":"<p>               Bases: <code>BaseModel</code></p> <p>JSON config model.</p> <p>Parameters:</p> Name Type Description Default <code>user</code> <code>str</code> <p>RabbitMQ user.</p> required <code>password</code> <code>str</code> <p>RabbitMQ password.</p> required <code>host</code> <code>str</code> <p>RabbitMQ vhost.</p> required <code>kwargs</code> <code>dict</code> <p>RabbitMQ additional kwargs.</p> <code>{}</code> Source code in <code>stac_generator/plugins/bulk_outputs/rabbit_mq.py</code> <pre><code>class RabbitMQConnection(BaseModel):\n    \"\"\"JSON config model.\"\"\"\n\n    user: str = Field(\n        description=\"RabbitMQ user.\",\n    )\n    password: str = Field(\n        description=\"RabbitMQ password.\",\n    )\n    host: str = Field(\n        description=\"RabbitMQ host.\",\n    )\n    host: str = Field(\n        description=\"RabbitMQ vhost.\",\n    )\n    kwargs: dict = Field(\n        default={},\n        description=\"RabbitMQ additional kwargs.\",\n    )\n</code></pre>"},{"location":"bulk_outputs/rabbit_mq/#stac_generator.plugins.bulk_outputs.rabbit_mq.RabbitMQExchange","title":"<code>RabbitMQExchange</code>","text":"<p>               Bases: <code>BaseModel</code></p> <p>JSON config model.</p> <p>Parameters:</p> Name Type Description Default <code>name</code> <code>str</code> <p>RabbitMQ exchange name.</p> required <code>type</code> <code>str</code> <p>RabbitMQ exchange type.</p> required <code>routing_key</code> <code>str</code> <p>RabbitMQ exchange routing key.</p> <code>''</code> Source code in <code>stac_generator/plugins/bulk_outputs/rabbit_mq.py</code> <pre><code>class RabbitMQExchange(BaseModel):\n    \"\"\"JSON config model.\"\"\"\n\n    name: str = Field(\n        description=\"RabbitMQ exchange name.\",\n    )\n    type: str = Field(\n        description=\"RabbitMQ exchange type.\",\n    )\n    routing_key: str = Field(\n        default=\"\",\n        description=\"RabbitMQ exchange routing key.\",\n    )\n</code></pre>"},{"location":"bulk_outputs/standard_out/","title":"Standard out","text":""},{"location":"bulk_outputs/standard_out/#stac_generator.plugins.bulk_outputs.standard_out.StandardOutBulkOutput","title":"<code>StandardOutBulkOutput</code>","text":"<p>               Bases: <code>BulkOutput</code></p> <p>Outputs to standard out. Useful for testing and debugging.</p> <p>Plugin name: <code>standard_out_bulk</code></p> Example configuration <p>.. code-block:: yaml</p> <pre><code>- name: standard_out_bulk\n  conf:\n    cache_max_size: 10\n</code></pre> Source code in <code>stac_generator/plugins/bulk_outputs/standard_out.py</code> <pre><code>class StandardOutBulkOutput(BulkOutput):\n    \"\"\"\n    Outputs to standard out.\n    Useful for testing and debugging.\n\n    **Plugin name:** ``standard_out_bulk``\n\n    Example configuration:\n        .. code-block:: yaml\n\n            - name: standard_out_bulk\n              conf:\n                cache_max_size: 10\n    \"\"\"\n\n    def export(self, data_list: list) -&gt; None:\n        \"\"\"\n        Print the data if cache is full.\n\n        :param data: expected data\n        \"\"\"\n        print(json.dumps(data_list, indent=4))\n</code></pre>"},{"location":"bulk_outputs/standard_out/#stac_generator.plugins.bulk_outputs.standard_out.StandardOutBulkOutput.export","title":"<code>export(data_list)</code>","text":"<p>Print the data if cache is full.</p> <p>:param data: expected data</p> Source code in <code>stac_generator/plugins/bulk_outputs/standard_out.py</code> <pre><code>def export(self, data_list: list) -&gt; None:\n    \"\"\"\n    Print the data if cache is full.\n\n    :param data: expected data\n    \"\"\"\n    print(json.dumps(data_list, indent=4))\n</code></pre>"},{"location":"inputs/elasticsearch_aggregation/","title":"Elasticsearch aggregation","text":""},{"location":"inputs/elasticsearch_aggregation/#stac_generator.plugins.inputs.elasticsearch_aggregation.ElasticsearchAggregationInput","title":"<code>ElasticsearchAggregationInput</code>","text":"<p>               Bases: <code>Input</code></p> <p>Preforms an Elasticsearch Aggregation to provide a stream of events for procesing.</p> <p>Plugin name: <code>elasticsearch</code></p> Example Configuration <p>.. code-block:: yaml</p> <pre><code>name: elasticsearch\nconf:\n  id_term: item_id\n  connection_kwargs:\n  index: ceda-index\n  hosts: ['host1:9200','host2:9200']\n  request_timeout: 60\n</code></pre> Source code in <code>stac_generator/plugins/inputs/elasticsearch_aggregation.py</code> <pre><code>class ElasticsearchAggregationInput(Input):\n    \"\"\"\n    Preforms an [Elasticsearch Aggregation](https://www.elastic.co/)\n    to provide a stream of events for procesing.\n\n    **Plugin name:** ``elasticsearch``\n\n    Example Configuration:\n        .. code-block:: yaml\n\n            name: elasticsearch\n            conf:\n              id_term: item_id\n              connection_kwargs:\n              index: ceda-index\n              hosts: ['host1:9200','host2:9200']\n              request_timeout: 60\n    \"\"\"\n\n    config_class = ElasticsearchConf\n\n    def __init__(self, **kwargs):\n        super().__init__(**kwargs)\n        self.id_term = kwargs[\"id_term\"]\n        self.index = kwargs[\"index\"]\n\n        self.search_kwargs = kwargs.get(\"search_kwargs\")\n\n    def run(self):\n        start = datetime.now()\n        total_generated = 0\n\n        es_client = Elasticsearch(**self.conf.client_kwargs)\n\n        body = {\n            \"query\": self.conf.query,\n            \"aggs\": {\n                \"bucket\": {\n                    \"composite\": {\n                        \"sources\": [\n                            {\n                                \"uri\": {\n                                    \"terms\": {\"field\": {self.conf.uri_term}},\n                                }\n                            },\n                            {\n                                \"recipe_path\": {\n                                    \"terms\": {\"field\": \"recipe_path.keyword\"},\n                                }\n                            },\n                        ],\n                        \"size\": 100,\n                    }\n                }\n            },\n            \"size\": 0,\n        }\n\n        for extra_term in self.conf.extra_terms:\n            body[\"bucket\"][\"composite\"][extra_term.key] = {\n                \"terms\": {\"field\": f\"{extra_term.key}\"},\n            }\n\n        while True:\n            result = es_client.search(\n                index=self.index, body=body, request_timeout=self.conf.request_timeout\n            )\n\n            aggregation = result[\"aggregations\"][\"bucket\"]\n\n            for bucket in aggregation[\"buckets\"]:\n                output = {\"uri\": bucket[\"key\"][\"uri\"]}\n\n                for extra_term in self.conf.extra_terms:\n                    output[extra_term.output_key] = bucket[\"key\"][extra_term.key]\n\n                yield output\n                total_generated += 1\n\n            if \"after_key\" not in aggregation.keys():\n                break\n\n            body[\"aggs\"][\"bucket\"][\"composite\"][\"after\"] = aggregation[\"after_key\"]\n\n        end = datetime.now()\n        print(f\"Processed {total_generated} elasticsearch records in {end-start}\")\n</code></pre>"},{"location":"inputs/elasticsearch_aggregation/#stac_generator.plugins.inputs.elasticsearch_aggregation.ElasticsearchConf","title":"<code>ElasticsearchConf</code>","text":"<p>               Bases: <code>BaseModel</code></p> <p>Elasticsearch config model.</p> Source code in <code>stac_generator/plugins/inputs/elasticsearch_aggregation.py</code> <pre><code>class ElasticsearchConf(BaseModel):\n    \"\"\"Elasticsearch config model.\"\"\"\n\n    index: ElasticsearchIndex = Field(\n        description=\"Elasticsearch index to post to.\",\n    )\n    uri_term: str = Field(\n        default=\"uri.keyword\",\n        description=\"Term to use as uri.\",\n    )\n    client_kwargs: dict = Field(\n        default={},\n        description=\"Elasticsearch connection kwargs.\",\n    )\n    extra_terms: list[KeyOutputKey] = Field(\n        default=[],\n        description=\"List of extra terms.\",\n    )\n    query: dict = Field(\n        default={},\n        description=\"Elasticsearch search query.\",\n    )\n    request_timeout: int = Field(\n        default=60,\n        description=\"Request timeout for search.\",\n    )\n</code></pre>"},{"location":"inputs/elasticsearch_aggregation/#stac_generator.plugins.inputs.elasticsearch_aggregation.ElasticsearchIndex","title":"<code>ElasticsearchIndex</code>","text":"<p>               Bases: <code>BaseModel</code></p> <p>Elasticsearch index model.</p> Source code in <code>stac_generator/plugins/inputs/elasticsearch_aggregation.py</code> <pre><code>class ElasticsearchIndex(BaseModel):\n    \"\"\"Elasticsearch index model.\"\"\"\n\n    name: str = Field(\n        description=\"Name of index.\",\n    )\n    mapping: str | dict = Field(\n        default={},\n        description=\"Index initial mapping.\",\n    )\n</code></pre>"},{"location":"inputs/file_system/","title":"File system","text":""},{"location":"inputs/file_system/#stac_generator.plugins.inputs.file_system.FileSystemConf","title":"<code>FileSystemConf</code>","text":"<p>               Bases: <code>BaseModel</code></p> <p>File system config.</p> <p>Parameters:</p> Name Type Description Default <code>path</code> <code>str</code> <p>Root path to begin walk.</p> required <code>kwargs</code> <code>dict</code> <p>os walk kwargs.</p> <code>{}</code> Source code in <code>stac_generator/plugins/inputs/file_system.py</code> <pre><code>class FileSystemConf(BaseModel):\n    \"\"\"File system config.\"\"\"\n\n    path: str = Field(\n        description=\"Root path to begin walk.\",\n    )\n    kwargs: dict = Field(\n        default={},\n        description=\"os walk kwargs.\",\n    )\n</code></pre>"},{"location":"inputs/file_system/#stac_generator.plugins.inputs.file_system.FileSystemInput","title":"<code>FileSystemInput</code>","text":"<p>               Bases: <code>Input</code></p> <p>Performs an os.walk to provide a stream of messages for procesing.</p> <p>Plugin name: <code>file_system</code></p> Example Configuration <p>.. code-block:: yaml</p> <p>name: file_system   conf:     path: test_directory</p> Source code in <code>stac_generator/plugins/inputs/file_system.py</code> <pre><code>class FileSystemInput(Input):\n    \"\"\"\n    Performs an os.walk to provide a stream of messages for procesing.\n\n    **Plugin name:** ``file_system``\n\n    Example Configuration:\n      .. code-block:: yaml\n\n        name: file_system\n        conf:\n          path: test_directory\n    \"\"\"\n\n    config_class = FileSystemConf\n\n    def run(self):\n        total_files = 0\n        start = datetime.now()\n        for root, _, files in tqdm(os.walk(self.conf.path, **self.conf.kwargs)):\n            for file in files:\n                filename = os.path.abspath(os.path.join(root, file))\n                logger.debug(\"Input processing: %s\", filename)\n\n                yield {\"uri\": filename}\n                total_files += 1\n\n        end = datetime.now()\n        print(f\"Processed {total_files} files from {self.conf.path} in {end-start}\")\n</code></pre>"},{"location":"inputs/intake_esm/","title":"Intake esm","text":""},{"location":"inputs/intake_esm/#stac_generator.plugins.inputs.intake_esm.IntakeESMConf","title":"<code>IntakeESMConf</code>","text":"<p>               Bases: <code>BaseModel</code></p> <p>IntakeESM config.</p> Source code in <code>stac_generator/plugins/inputs/intake_esm.py</code> <pre><code>class IntakeESMConf(BaseModel):\n    \"\"\"IntakeESM config.\"\"\"\n\n    url: str = Field(\n        description=\"URL of datastore.\",\n    )\n    uri_term: str = Field(\n        description=\"Attritube to use as uri.\",\n    )\n    extra_terms: list[KeyOutputKey] = Field(\n        default=[],\n        description=\"List of extra attributes.\",\n    )\n    skip: int = Field(\n        default=-1,\n        description=\"Number of rows to skip.\",\n    )\n    catalog_kwargs: dict = Field(\n        default={},\n        description=\"catalog kwargs.\",\n    )\n    search_kwargs: dict = Field(\n        default={},\n        description=\"search kwargs.\",\n    )\n</code></pre>"},{"location":"inputs/intake_esm/#stac_generator.plugins.inputs.intake_esm.IntakeESMInput","title":"<code>IntakeESMInput</code>","text":"<p>               Bases: <code>Input</code></p> <p>Uses an <code>Intake catalog &lt;https://intake.readthedocs.io/&gt;</code>_ as a source for events.</p> <p>Plugin name: <code>intake_esm</code></p> Example Configuration <p>.. code-block:: yaml</p> <pre><code>name: intake_esm\nconf:\n  uri: test_directory\n</code></pre> Source code in <code>stac_generator/plugins/inputs/intake_esm.py</code> <pre><code>class IntakeESMInput(Input):\n    \"\"\"\n    Uses an `Intake catalog &lt;https://intake.readthedocs.io/&gt;`_\n    as a source for events.\n\n    **Plugin name:** ``intake_esm``\n\n\n    Example Configuration:\n        .. code-block:: yaml\n\n            name: intake_esm\n            conf:\n              uri: test_directory\n    \"\"\"\n\n    config_class = IntakeESMConf\n\n    def run(self):\n        total_files = 0\n        start = datetime.now()\n\n        LOGGER.info(\"Opening catalog %s\", self.conf.url)\n        catalog = intake.open_esm_datastore(self.conf.url, **self.conf.catalog_kwargs)\n\n        if self.conf.search_kwargs:\n            LOGGER.info(\"Searching catalog\")\n            catalog = catalog.search(**self.conf.search_kwargs)\n\n        LOGGER.info(\"Found %s items\", len(catalog.df))\n\n        count = 0\n        for _, row in catalog.df.iterrows():\n            if count &gt; self.conf.skip:\n                output = {\"uri\": getattr(row, self.conf.uri_term)}\n                LOGGER.debug(\"Input processing: %s\", output[\"uri\"])\n\n                for extra_term in self.conf.extra_terms:\n                    output[extra_term.output_key] = getattr(row, extra_term.key)\n\n                yield output\n                total_files += 1\n\n            count += 1\n\n        end = datetime.now()\n        print(f\"Processed {total_files} files from {self.conf.url} in {end-start}\")\n</code></pre>"},{"location":"inputs/object_store/","title":"Object store","text":""},{"location":"inputs/object_store/#stac_generator.plugins.inputs.object_store.ObjectStoreConf","title":"<code>ObjectStoreConf</code>","text":"<p>               Bases: <code>BaseModel</code></p> <p>Object Store Config.</p> <p>Parameters:</p> Name Type Description Default <code>url</code> <code>str</code> <p>URL of datastore.</p> required <code>buckets</code> <code>list[str]</code> <p>Number of rows to skip.</p> <code>-1</code> <code>prefix</code> <code>str</code> <p>URL of datastore.</p> required <code>delimiter</code> <code>str</code> <p>URL of datastore.</p> required <code>session_kwargs</code> <code>dict</code> <p>session kwargs.</p> <code>{}</code> Source code in <code>stac_generator/plugins/inputs/object_store.py</code> <pre><code>class ObjectStoreConf(BaseModel):\n    \"\"\"Object Store Config.\"\"\"\n\n    url: str = Field(\n        description=\"URL of datastore.\",\n    )\n    buckets: list[str] = Field(\n        default=-1,\n        description=\"Number of rows to skip.\",\n    )\n    prefix: str = Field(\n        description=\"URL of datastore.\",\n    )\n    delimiter: str = Field(\n        description=\"URL of datastore.\",\n    )\n    session_kwargs: dict = Field(\n        default={},\n        description=\"session kwargs.\",\n    )\n</code></pre>"},{"location":"inputs/object_store/#stac_generator.plugins.inputs.object_store.ObjectStoreInput","title":"<code>ObjectStoreInput</code>","text":"<p>               Bases: <code>Input</code></p> <p>Takes an endpoint url and optionally a bucket prefix and delimiter and will scan the object store at these points to produce events.</p> <p>Plugin name: <code>object_store</code></p> Example Configuration <p>.. code-block:: yaml</p> <pre><code>name: object_store\nconf:\n  endpoint_url: https://cedadev-o.s3-ext.jc.rl.ac.uk\n  session_kwargs:\n    aws_access_key_id: ACCESS_KEY,\n    aws_secret_access_key: SECRET_KEY\n  buckets:\n    - my_bucket\n  prefix: directory_or_file\n  delimiter: .zarr/\n</code></pre> Source code in <code>stac_generator/plugins/inputs/object_store.py</code> <pre><code>class ObjectStoreInput(Input):\n    \"\"\"\n    Takes an endpoint url and optionally a bucket prefix and delimiter and will\n    scan the object store at these points to produce events.\n\n    **Plugin name:** ``object_store``\n\n    Example Configuration:\n        .. code-block:: yaml\n\n            name: object_store\n            conf:\n              endpoint_url: https://cedadev-o.s3-ext.jc.rl.ac.uk\n              session_kwargs:\n                aws_access_key_id: ACCESS_KEY,\n                aws_secret_access_key: SECRET_KEY\n              buckets:\n                - my_bucket\n              prefix: directory_or_file\n              delimiter: .zarr/\n\n    \"\"\"\n\n    config_class = ObjectStoreConf\n\n    def run(self):\n\n        session = boto3.session.Session(**self.conf.session_kwargs)\n        s3 = session.resource(\n            \"s3\",\n            endpoint_url=self.conf.url,\n        )\n\n        buckets = (\n            [s3.Bucket(bucket) for bucket in self.conf.buckets]\n            if self.conf.buckets\n            else s3.buckets.all()\n        )\n\n        for bucket in buckets:\n            total_files = 0\n\n            for obj in bucket.objects.filter(\n                Prefix=self.conf.prefix, Delimiter=self.conf.delimiter\n            ):\n\n                yield {\n                    \"uri\": f\"{self.conf.url}/{bucket.name}/{obj.key}\",\n                    \"client\": s3.meta.client,\n                }\n                total_files += 1\n\n            LOGGER.info(\"Processed %s files from %s\", total_files, bucket)\n</code></pre>"},{"location":"inputs/rabbit_mq/","title":"Rabbit mq","text":""},{"location":"inputs/rabbit_mq/#stac_generator.plugins.inputs.rabbit_mq.RabbitMQConf","title":"<code>RabbitMQConf</code>","text":"<p>               Bases: <code>BaseModel</code></p> <p>RabbitMQ config model.</p> <p>Parameters:</p> Name Type Description Default <code>connection</code> <code>RabbitMQConnection</code> <p>RabbitMQ connection kwargs.</p> required <code>exchange</code> <code>RabbitMQExchange</code> <p>RabbitMQ exchange info.</p> required <code>queues</code> <code>list[RabbitMQQueue]</code> <p>RabbitMQ queues to bind.</p> <code>[]</code> <code>uri_term</code> <code>str</code> <p>Attritube to use as uri.</p> <code>'uri'</code> <code>extra_terms</code> <code>list[KeyOutputKey]</code> <p>List of extra attributes.</p> <code>[]</code> Source code in <code>stac_generator/plugins/inputs/rabbit_mq.py</code> <pre><code>class RabbitMQConf(BaseModel):\n    \"\"\"RabbitMQ config model.\"\"\"\n\n    connection: RabbitMQConnection = Field(\n        description=\"RabbitMQ connection kwargs.\",\n    )\n    exchange: RabbitMQExchange = Field(\n        description=\"RabbitMQ exchange info.\",\n    )\n    queues: list[RabbitMQQueue] = Field(\n        default=[],\n        description=\"RabbitMQ queues to bind.\",\n    )\n    uri_term: str = Field(description=\"Attritube to use as uri.\", default=\"uri\")\n    extra_terms: list[KeyOutputKey] = Field(\n        default=[],\n        description=\"List of extra attributes.\",\n    )\n</code></pre>"},{"location":"inputs/rabbit_mq/#stac_generator.plugins.inputs.rabbit_mq.RabbitMQConnection","title":"<code>RabbitMQConnection</code>","text":"<p>               Bases: <code>BaseModel</code></p> <p>RabbitMQ Connection model.</p> <p>Parameters:</p> Name Type Description Default <code>user</code> <code>str</code> <p>RabbitMQ user.</p> required <code>password</code> <code>str</code> <p>RabbitMQ password.</p> required <code>host</code> <code>str</code> <p>RabbitMQ host.</p> required <code>vhost</code> <code>str</code> <p>RabbitMQ vhost.</p> required <code>kwargs</code> <code>dict</code> <p>RabbitMQ additional kwargs.</p> <code>{}</code> Source code in <code>stac_generator/plugins/inputs/rabbit_mq.py</code> <pre><code>class RabbitMQConnection(BaseModel):\n    \"\"\"RabbitMQ Connection model.\"\"\"\n\n    user: str = Field(\n        description=\"RabbitMQ user.\",\n    )\n    password: str = Field(\n        description=\"RabbitMQ password.\",\n    )\n    host: str = Field(\n        description=\"RabbitMQ host.\",\n    )\n    vhost: str = Field(\n        description=\"RabbitMQ vhost.\",\n    )\n    kwargs: dict = Field(\n        default={},\n        description=\"RabbitMQ additional kwargs.\",\n    )\n</code></pre>"},{"location":"inputs/rabbit_mq/#stac_generator.plugins.inputs.rabbit_mq.RabbitMQExchange","title":"<code>RabbitMQExchange</code>","text":"<p>               Bases: <code>BaseModel</code></p> <p>RabbitMQ Exchange model.</p> <p>Parameters:</p> Name Type Description Default <code>name</code> <code>str</code> <p>RabbitMQ exchange name.</p> required <code>type</code> <code>str</code> <p>RabbitMQ exchange type.</p> <code>'topic'</code> <code>kwargs</code> <code>dict</code> <p>RabbitMQ exchange kwargs.</p> <code>{}</code> Source code in <code>stac_generator/plugins/inputs/rabbit_mq.py</code> <pre><code>class RabbitMQExchange(BaseModel):\n    \"\"\"RabbitMQ Exchange model.\"\"\"\n\n    name: str = Field(\n        description=\"RabbitMQ exchange name.\",\n    )\n    type: str = Field(\n        default=\"topic\",\n        description=\"RabbitMQ exchange type.\",\n    )\n    kwargs: dict = Field(\n        default={},\n        description=\"RabbitMQ exchange kwargs.\",\n    )\n</code></pre>"},{"location":"inputs/rabbit_mq/#stac_generator.plugins.inputs.rabbit_mq.RabbitMQInput","title":"<code>RabbitMQInput</code>","text":"<p>               Bases: <code>BlockingInput</code></p> <p>Uses a <code>RabbitMQ Queue &lt;https://www.rabbitmq.com/&gt;</code>_ as a source for events.</p> <p>Plugin name: <code>rabbitmq</code></p> Example Configuration <p>.. code-block:: yaml</p> <pre><code>name: rabbitmq\nconf:\n  connection:\n    host: my-rabbit-server.co.uk\n    user: user\n    password: '*********'\n    vhost: my_virtual_host\n    kwargs:\n      heartbeat: 300\n  exchange:\n    source_exchange:\n      name: mysource-exchange\n      type: fanout\n    destination_exchange:\n      name: mydest-exchange\n      type: fanout\n  queues:\n    - kwargs:\n        durable: true\n      bind_kwargs:\n        routing_key: my.routing.key\n      consume_kwargs:\n        auto_ack: false\n</code></pre> Source code in <code>stac_generator/plugins/inputs/rabbit_mq.py</code> <pre><code>class RabbitMQInput(BlockingInput):\n    \"\"\"\n    Uses a `RabbitMQ Queue &lt;https://www.rabbitmq.com/&gt;`_ as a source for events.\n\n    **Plugin name:** ``rabbitmq``\n\n    Example Configuration:\n        .. code-block:: yaml\n\n            name: rabbitmq\n            conf:\n              connection:\n                host: my-rabbit-server.co.uk\n                user: user\n                password: '*********'\n                vhost: my_virtual_host\n                kwargs:\n                  heartbeat: 300\n              exchange:\n                source_exchange:\n                  name: mysource-exchange\n                  type: fanout\n                destination_exchange:\n                  name: mydest-exchange\n                  type: fanout\n              queues:\n                - kwargs:\n                    durable: true\n                  bind_kwargs:\n                    routing_key: my.routing.key\n                  consume_kwargs:\n                    auto_ack: false\n\n    \"\"\"\n\n    config_class = RabbitMQConf\n\n    @staticmethod\n    def decode_message(body: bytes) -&gt; dict:\n        \"\"\"\n        Takes the message and turns into a dictionary.\n        String message format when split on :\n            date_hour = split_line[0]\n            min = split_line[1]\n            sec = split_line[2]\n            path = split_line[3]\n            action = split_line[4]\n            filesize = split_line[5]\n            message = \":\".join(split_line[6:])\n\n        :param body: Message body, either a json string or text\n\n        \"\"\"\n\n        # Decode the byte string to utf-8\n        body = body.decode(\"utf-8\")\n\n        LOGGER.info(\"RabbitMQ message recieved: %s\", body)\n\n        try:\n            msg = json.loads(body)\n\n        except json.JSONDecodeError:\n            try:\n                msg = ast.literal_eval(body)\n\n            except (ValueError, SyntaxError):\n                # Assume the message is in the old format and split on :\n                split_line = body.strip().split(\":\")\n\n                msg = {\n                    \"datetime\": \":\".join(split_line[:3]),\n                    \"uri\": split_line[3],\n                    \"action\": split_line[4],\n                    \"filesize\": split_line[5],\n                    \"message\": \":\".join(split_line[6:]),\n                }\n\n        if \"uri\" not in msg:\n            msg[\"uri\"] = msg[\"filepath\"]\n\n        return msg\n\n    def _connect(self) -&gt; pika.channel.Channel:\n        \"\"\"\n        Start Pika connection to server. This is run in each thread.\n\n        :return: pika channel\n        \"\"\"\n\n        # Create the credentials object\n        credentials = pika.PlainCredentials(\n            self.conf.connection.user, self.conf.connection.password\n        )\n\n        # Start the rabbitMQ connection\n        connection = pika.BlockingConnection(\n            pika.ConnectionParameters(\n                host=self.conf.connection.host,\n                credentials=credentials,\n                virtual_host=self.conf.connection.vhost,\n                **self.conf.connection.kwargs,\n            )\n        )\n\n        # Create a new channel\n        channel = connection.channel()\n\n        channel.exchange_declare(\n            exchange=self.conf.exchange.name,\n            exchange_type=self.conf.exchange.type,\n            **self.conf.exchange.kwargs,\n        )\n        channel.basic_qos(prefetch_count=1)\n\n        # Declare queue and bind queue to the dest exchange\n        for queue in self.conf.queues:\n            channel.queue_declare(queue=queue.name, **queue.declare_kwargs)\n\n            channel.queue_bind(\n                exchange=self.conf.exchange.name, queue=queue.name, **queue.bind_kwargs\n            )\n\n            # Set callback\n            callback = functools.partial(self.callback, connection=connection)\n            channel.basic_consume(\n                queue=queue.name, on_message_callback=callback, **queue.consume_kwargs\n            )\n\n        return channel\n\n    @staticmethod\n    def _acknowledge_message(channel: pika.channel.Channel, delivery_tag: str):\n        \"\"\"\n        Acknowledge message\n\n        :param channel: Channel which message came from\n        :param delivery_tag: Message id\n        \"\"\"\n\n        LOGGER.debug(\"Acknowledging message: %s\", delivery_tag)\n        if channel.is_open:\n            channel.basic_ack(delivery_tag)\n\n    def acknowledge_message(\n        self,\n        channel: pika.channel.Channel,\n        delivery_tag: str,\n        connection: pika.connection.Connection,\n    ):\n        \"\"\"\n        Acknowledge message and move onto the next. All of the required\n        params come from the message callback params.\n\n        :param channel: callback channel param\n        :param delivery_tag: from the callback method param. eg. method.delivery_tag\n        :param connection: connection object from the callback param\n        \"\"\"\n        cb = functools.partial(self._acknowledge_message, channel, delivery_tag)\n        connection.add_callback_threadsafe(cb)\n\n    def callback(\n        self,\n        ch: pika.channel.Channel,\n        method: pika.frame.Method,\n        properties: pika.frame.Header,\n        body: bytes,\n        connection: pika.connection.Connection,\n    ) -&gt; None:\n\n        # Get message\n        try:\n            message = self.decode_message(body)\n\n        except IndexError:\n            # Acknowledge message if the message is not compliant\n            LOGGER.error(\"Unable to decode input message: %s\", body)\n            self.acknowledge_message(ch, method.delivery_tag, connection)\n            return\n\n        # Extract uri\n        output = {\"uri\": message[self.conf.uri_term]}\n\n        for extra_term in self.conf.extra_terms:\n            output[extra_term.output_key] = message[extra_term.key]\n\n        LOGGER.info(\"Input processing: %s message: %s\", message[self.conf.uri_term], message)\n\n        self.process_method(output)\n        self.acknowledge_message(ch, method.delivery_tag, connection)\n\n    def run(self, process_method: Callable):\n\n        self.process_method = process_method\n\n        while True:\n            channel = self._connect()\n\n            try:\n                LOGGER.info(\"READY\")\n                channel.start_consuming()\n\n            except KeyboardInterrupt:\n                channel.stop_consuming()\n                break\n\n            except pika.exceptions.StreamLostError as e:\n                # Log problem\n                LOGGER.error(\"Connection lost, reconnecting\", exc_info=e)\n                continue\n\n            except Exception as e:\n                LOGGER.critical(e, exc_info=True)\n\n                channel.stop_consuming()\n                break\n</code></pre>"},{"location":"inputs/rabbit_mq/#stac_generator.plugins.inputs.rabbit_mq.RabbitMQInput.acknowledge_message","title":"<code>acknowledge_message(channel, delivery_tag, connection)</code>","text":"<p>Acknowledge message and move onto the next. All of the required params come from the message callback params.</p> <p>:param channel: callback channel param :param delivery_tag: from the callback method param. eg. method.delivery_tag :param connection: connection object from the callback param</p> Source code in <code>stac_generator/plugins/inputs/rabbit_mq.py</code> <pre><code>def acknowledge_message(\n    self,\n    channel: pika.channel.Channel,\n    delivery_tag: str,\n    connection: pika.connection.Connection,\n):\n    \"\"\"\n    Acknowledge message and move onto the next. All of the required\n    params come from the message callback params.\n\n    :param channel: callback channel param\n    :param delivery_tag: from the callback method param. eg. method.delivery_tag\n    :param connection: connection object from the callback param\n    \"\"\"\n    cb = functools.partial(self._acknowledge_message, channel, delivery_tag)\n    connection.add_callback_threadsafe(cb)\n</code></pre>"},{"location":"inputs/rabbit_mq/#stac_generator.plugins.inputs.rabbit_mq.RabbitMQInput.decode_message","title":"<code>decode_message(body)</code>  <code>staticmethod</code>","text":"<p>Takes the message and turns into a dictionary. String message format when split on :     date_hour = split_line[0]     min = split_line[1]     sec = split_line[2]     path = split_line[3]     action = split_line[4]     filesize = split_line[5]     message = \":\".join(split_line[6:])</p> <p>:param body: Message body, either a json string or text</p> Source code in <code>stac_generator/plugins/inputs/rabbit_mq.py</code> <pre><code>@staticmethod\ndef decode_message(body: bytes) -&gt; dict:\n    \"\"\"\n    Takes the message and turns into a dictionary.\n    String message format when split on :\n        date_hour = split_line[0]\n        min = split_line[1]\n        sec = split_line[2]\n        path = split_line[3]\n        action = split_line[4]\n        filesize = split_line[5]\n        message = \":\".join(split_line[6:])\n\n    :param body: Message body, either a json string or text\n\n    \"\"\"\n\n    # Decode the byte string to utf-8\n    body = body.decode(\"utf-8\")\n\n    LOGGER.info(\"RabbitMQ message recieved: %s\", body)\n\n    try:\n        msg = json.loads(body)\n\n    except json.JSONDecodeError:\n        try:\n            msg = ast.literal_eval(body)\n\n        except (ValueError, SyntaxError):\n            # Assume the message is in the old format and split on :\n            split_line = body.strip().split(\":\")\n\n            msg = {\n                \"datetime\": \":\".join(split_line[:3]),\n                \"uri\": split_line[3],\n                \"action\": split_line[4],\n                \"filesize\": split_line[5],\n                \"message\": \":\".join(split_line[6:]),\n            }\n\n    if \"uri\" not in msg:\n        msg[\"uri\"] = msg[\"filepath\"]\n\n    return msg\n</code></pre>"},{"location":"inputs/rabbit_mq/#stac_generator.plugins.inputs.rabbit_mq.RabbitMQQueue","title":"<code>RabbitMQQueue</code>","text":"<p>               Bases: <code>BaseModel</code></p> <p>RabbitMQ Queue model.</p> <p>Parameters:</p> Name Type Description Default <code>name</code> <code>str</code> <p>RabbitMQ queue name.</p> required <code>declare_kwargs</code> <code>dict</code> <p>RabbitMQ declare kwargs.</p> <code>{}</code> <code>bind_kwargs</code> <code>dict</code> <p>RabbitMQ bind kwargs.</p> <code>{}</code> <code>consume_kwargs</code> <code>dict</code> <p>RabbitMQ consume kwargs.</p> <code>{}</code> Source code in <code>stac_generator/plugins/inputs/rabbit_mq.py</code> <pre><code>class RabbitMQQueue(BaseModel):\n    \"\"\"RabbitMQ Queue model.\"\"\"\n\n    name: str = Field(\n        description=\"RabbitMQ queue name.\",\n    )\n    declare_kwargs: dict = Field(\n        default={},\n        description=\"RabbitMQ declare kwargs.\",\n    )\n    bind_kwargs: dict = Field(\n        default={},\n        description=\"RabbitMQ bind kwargs.\",\n    )\n    consume_kwargs: dict = Field(\n        default={},\n        description=\"RabbitMQ consume kwargs.\",\n    )\n</code></pre>"},{"location":"inputs/solr/","title":"Solr","text":""},{"location":"inputs/solr/#stac_generator.plugins.inputs.solr.SolarParams","title":"<code>SolarParams</code>","text":"<p>               Bases: <code>BaseModel</code></p> <p>Solar parameters model.</p> <p>Parameters:</p> Name Type Description Default <code>indent</code> <code>str</code> <p>indent.</p> <code>'on'</code> <code>q</code> <code>str</code> <p>query.</p> <code>'*:*'</code> <code>wt</code> <code>str</code> <p>wt.</p> <code>'json'</code> <code>rows</code> <code>int</code> <p>Number of rows.</p> <code>10000</code> <code>sort</code> <code>str</code> <p>sort.</p> <code>'id asc'</code> <code>cursorMark</code> <code>str</code> <p>cursor mark.</p> <code>'*'</code> Source code in <code>stac_generator/plugins/inputs/solr.py</code> <pre><code>class SolarParams(BaseModel):\n    \"\"\"Solar parameters model.\"\"\"\n\n    indent: str = Field(\n        default=\"on\",\n        description=\"indent.\",\n    )\n    q: str = Field(\n        default=\"*:*\",\n        description=\"query.\",\n    )\n    wt: str = Field(\n        default=\"json\",\n        description=\"wt.\",\n    )\n    rows: int = Field(\n        default=10000,\n        description=\"Number of rows.\",\n    )\n    sort: str = Field(\n        default=\"id asc\",\n        description=\"sort.\",\n    )\n    cursorMark: str = Field(\n        default=\"*\",\n        description=\"cursor mark.\",\n    )\n</code></pre>"},{"location":"inputs/solr/#stac_generator.plugins.inputs.solr.SolrConf","title":"<code>SolrConf</code>","text":"<p>               Bases: <code>BaseModel</code></p> <p>Solar conf.</p> <p>Parameters:</p> Name Type Description Default <code>url</code> <code>str</code> <p>URL of datastore.</p> required <code>params</code> <code>SolarParams</code> <p>Parameters to pass to solr.</p> required <code>extra_terms</code> <code>list[KeyOutputKey]</code> <p>List of extra attributes.</p> <code>[]</code> Source code in <code>stac_generator/plugins/inputs/solr.py</code> <pre><code>class SolrConf(BaseModel):\n    \"\"\"Solar conf.\"\"\"\n\n    url: str = Field(\n        description=\"URL of datastore.\",\n    )\n    params: SolarParams = Field(\n        description=\"Parameters to pass to solr.\",\n    )\n    extra_terms: list[KeyOutputKey] = Field(\n        default=[],\n        description=\"List of extra attributes.\",\n    )\n</code></pre>"},{"location":"inputs/solr/#stac_generator.plugins.inputs.solr.SolrInput","title":"<code>SolrInput</code>","text":"<p>               Bases: <code>Input</code></p> <p>Uses a Solr index node for a source for events.</p> <p>Plugin name: <code>solr</code></p> Example Configuration <p>.. code-block:: yaml</p> <pre><code>name: solr\nconf:\n  index_node: url.index-node.ac.uk\n  search_params:\n    q: \"facet: value\"\n    rows: 10000\n</code></pre> Source code in <code>stac_generator/plugins/inputs/solr.py</code> <pre><code>class SolrInput(Input):\n    \"\"\"\n    Uses a Solr index node for a source for events.\n\n    **Plugin name:** ``solr``\n\n    Example Configuration:\n        .. code-block:: yaml\n\n            name: solr\n            conf:\n              index_node: url.index-node.ac.uk\n              search_params:\n                q: \"facet: value\"\n                rows: 10000\n    \"\"\"\n\n    config_class = SolrConf\n\n    def iter_docs(self):\n        \"\"\"\n        Core loop to iterate through the Solr response.\n        \"\"\"\n        n = 0\n        while True:\n            try:\n                resp = requests.get(self.conf.url, self.conf.params.dict())\n            except requests.exceptions.ConnectionError as e:\n                LOGGER.error(\"Failed to establish connection to %s:\\n%s\", self.conf.url, e)\n                sys.exit(1)\n\n            resp = resp.json()\n            docs = resp[\"response\"][\"docs\"]\n\n            # Return the list of files to the for loop and continue paginating\n            yield from docs\n\n            n += len(docs)\n            LOGGER.info(\"%s/%s\\n\", n, resp[\"response\"][\"numFound\"])\n            if not docs:\n                LOGGER.error(\"no docs found\")\n                break\n            LOGGER.info(\"Next cursormark at position %s\", n)\n\n            # Change the search params to get next page.\n            self.conf.params.cursorMark = resp[\"nextCursorMark\"]\n\n    def run(self):\n        for doc in self.iter_docs():\n            uri: str = doc.get(\"id\")\n\n            LOGGER.info(\"Input processing: %s\", uri)\n\n            # transform id to a uri\n            # by replacing '.' with '/' up until the filename\n            output = {\"uri\": uri.replace(\".\", \"/\", uri.split(\"|\")[0].count(\".\") - 1)}\n\n            for extra_term in self.conf.extra_terms:\n                output[extra_term.output_key] = doc.get(extra_term.key)\n\n            yield output\n</code></pre>"},{"location":"inputs/solr/#stac_generator.plugins.inputs.solr.SolrInput.iter_docs","title":"<code>iter_docs()</code>","text":"<p>Core loop to iterate through the Solr response.</p> Source code in <code>stac_generator/plugins/inputs/solr.py</code> <pre><code>def iter_docs(self):\n    \"\"\"\n    Core loop to iterate through the Solr response.\n    \"\"\"\n    n = 0\n    while True:\n        try:\n            resp = requests.get(self.conf.url, self.conf.params.dict())\n        except requests.exceptions.ConnectionError as e:\n            LOGGER.error(\"Failed to establish connection to %s:\\n%s\", self.conf.url, e)\n            sys.exit(1)\n\n        resp = resp.json()\n        docs = resp[\"response\"][\"docs\"]\n\n        # Return the list of files to the for loop and continue paginating\n        yield from docs\n\n        n += len(docs)\n        LOGGER.info(\"%s/%s\\n\", n, resp[\"response\"][\"numFound\"])\n        if not docs:\n            LOGGER.error(\"no docs found\")\n            break\n        LOGGER.info(\"Next cursormark at position %s\", n)\n\n        # Change the search params to get next page.\n        self.conf.params.cursorMark = resp[\"nextCursorMark\"]\n</code></pre>"},{"location":"inputs/text_file/","title":"Text file","text":""},{"location":"inputs/text_file/#stac_generator.plugins.inputs.text_file.TextFileConf","title":"<code>TextFileConf</code>","text":"<p>               Bases: <code>BaseModel</code></p> <p>Text file Config.</p> <p>Parameters:</p> Name Type Description Default <code>path</code> <code>str</code> <p>Path to file or directory of files.</p> required <code>uri_term</code> <code>str</code> <p>Attritube to use as uri.</p> <code>'uri'</code> <code>extra_terms</code> <code>list[KeyOutputKey]</code> <p>List of extra attributes.</p> <code>[]</code> Source code in <code>stac_generator/plugins/inputs/text_file.py</code> <pre><code>class TextFileConf(BaseModel):\n    \"\"\"Text file Config.\"\"\"\n\n    path: str = Field(\n        description=\"Path to file or directory of files.\",\n    )\n    uri_term: str = Field(\n        default=\"uri\",\n        description=\"Attritube to use as uri.\",\n    )\n    extra_terms: list[KeyOutputKey] = Field(\n        default=[],\n        description=\"List of extra attributes.\",\n    )\n</code></pre>"},{"location":"inputs/text_file/#stac_generator.plugins.inputs.text_file.TextFileInput","title":"<code>TextFileInput</code>","text":"<p>               Bases: <code>Input</code></p> <p>Reads lines from file/files as a source for events.</p> <p>Plugin name: <code>text_file</code></p> Example Configuration <p>.. code-block:: yaml</p> <pre><code>- name: text_file\n  conf:\n    filepath: /path/to/files\n</code></pre> Source code in <code>stac_generator/plugins/inputs/text_file.py</code> <pre><code>class TextFileInput(Input):\n    \"\"\"\n    Reads lines from file/files as a source for events.\n\n    **Plugin name:** ``text_file``\n\n    Example Configuration:\n        .. code-block:: yaml\n\n            - name: text_file\n              conf:\n                filepath: /path/to/files\n    \"\"\"\n\n    config_class = TextFileConf\n\n    def run(self):\n\n        if isdir(self.conf.path):\n            file_list = [\n                join(self.conf.path, file)\n                for file in listdir(self.conf.path)\n                if isfile(join(self.conf.path, file))\n            ]\n\n        else:\n            file_list = [self.conf.path]\n\n        start = datetime.now()\n        total_generated = 0\n        unique_lines = set()\n\n        for file in file_list:\n            with (open(file, \"r\", encoding=\"utf-8\") as f,):\n                for line in f:\n                    if line not in unique_lines:\n                        unique_lines.add(line)\n\n                        data = json.loads(line)\n                        output = {\"uri\": data[self.conf.uri_term]}\n\n                        for extra_term in self.conf.extra_terms:\n                            output[extra_term.output_key] = data[extra_term.key]\n\n                        yield output\n                        total_generated += 1\n\n        end = datetime.now()\n        print(f\"Processed {total_generated} elasticsearch records in {end-start}\")\n</code></pre>"},{"location":"inputs/thredds/","title":"Thredds","text":""},{"location":"inputs/thredds/#stac_generator.plugins.inputs.thredds.ThreddsConf","title":"<code>ThreddsConf</code>","text":"<p>               Bases: <code>BaseModel</code></p> <p>Thredds Config.</p> <p>Parameters:</p> Name Type Description Default <code>url</code> <code>str</code> <p>URL of Thredds server.</p> required <code>depth</code> <code>int</code> <p>Depth of catalog walk.</p> <code>1000</code> <code>uri_term</code> <code>str</code> <p>Attritube to use as uri.</p> required <code>extra_terms</code> <code>list[KeyOutputKey]</code> <p>List of extra attributes.</p> <code>[]</code> Source code in <code>stac_generator/plugins/inputs/thredds.py</code> <pre><code>class ThreddsConf(BaseModel):\n    \"\"\"Thredds Config.\"\"\"\n\n    url: str = Field(\n        description=\"URL of Thredds server.\",\n    )\n    depth: int = Field(\n        default=1000,\n        description=\"Depth of catalog walk.\",\n    )\n    uri_term: str = Field(\n        description=\"Attritube to use as uri.\",\n    )\n    extra_terms: list[KeyOutputKey] = Field(\n        default=[],\n        description=\"List of extra attributes.\",\n    )\n</code></pre>"},{"location":"inputs/thredds/#stac_generator.plugins.inputs.thredds.ThreddsInput","title":"<code>ThreddsInput</code>","text":"<p>               Bases: <code>Input</code></p> <p>Uses a <code>Thredds Data Server &lt;https://www.unidata.ucar.edu/software/tds/current/&gt;</code>_ as an event source.</p> <p>Plugin name: <code>thredds</code></p> Example Configuration <p>.. code-block:: yaml</p> <pre><code>- name: thredds\n  conf:\n    uri: test-url\n    object_path_attr: access_urls.OPENDAP\n</code></pre> Source code in <code>stac_generator/plugins/inputs/thredds.py</code> <pre><code>class ThreddsInput(Input):\n    \"\"\"\n    Uses a `Thredds Data Server &lt;https://www.unidata.ucar.edu/software/tds/current/&gt;`_\n    as an event source.\n\n    **Plugin name:** ``thredds``\n\n    Example Configuration:\n        .. code-block:: yaml\n\n            - name: thredds\n              conf:\n                uri: test-url\n                object_path_attr: access_urls.OPENDAP\n\n    \"\"\"\n\n    config_class = ThreddsConf\n\n    def walk_tds(self, catalog: TDSCatalog, depth: int) -&gt; Iterator:\n        \"\"\"\n        Return a generator walking a THREDDS data catalog for datasets.\n\n        :param cat: THREDDS catalog.\n        :param depth: Maximum recursive depth.\n        \"\"\"\n        yield from catalog.datasets.items()\n\n        if depth &gt; 0:\n            for _, ref in catalog.catalog_refs.items():\n                child = ref.follow()\n                yield from self.walk_tds(catalog=child, depth=depth - 1)\n\n    def get_sub_attr(self, obj: object, path: str):\n        \"\"\"\n        Returns a child or sub-child attribute of a dict object.\n\n        :param obj: Object\n        :param path: 'attr1.attr2.etc'\n        :return: obj.attr1.attr2.etc\n        \"\"\"\n        attrs = path.split(\".\")\n\n        for attr in attrs:\n            if isinstance(obj, CaseInsensitiveDict):\n                obj = obj[attr]\n                continue\n\n            obj = getattr(obj, attr)\n\n        return obj\n\n    def run(self):\n        \"\"\"\n        Plugin's entrypoint.\n\n        \"\"\"\n        total_generated = 0\n        start = datetime.now()\n\n        catalog = TDSCatalog(self.conf.url, **self.conf.thredds_kwargs)\n\n        for _, dataset in self.walk_tds(catalog=catalog, depth=self.conf.depth):\n            output = {\"uri\": self.get_sub_attr(dataset, self.conf.uri_term)}\n\n            for extra_term in self.conf.extra_terms:\n                output[extra_term.output_key] = self.get_sub_attr(dataset, extra_term.key)\n\n            yield output\n            total_generated += 1\n\n        end = datetime.now()\n        print(f\"Processed {total_generated} records from {self.conf.url} in {end - start}\")\n</code></pre>"},{"location":"inputs/thredds/#stac_generator.plugins.inputs.thredds.ThreddsInput.get_sub_attr","title":"<code>get_sub_attr(obj, path)</code>","text":"<p>Returns a child or sub-child attribute of a dict object.</p> <p>:param obj: Object :param path: 'attr1.attr2.etc' :return: obj.attr1.attr2.etc</p> Source code in <code>stac_generator/plugins/inputs/thredds.py</code> <pre><code>def get_sub_attr(self, obj: object, path: str):\n    \"\"\"\n    Returns a child or sub-child attribute of a dict object.\n\n    :param obj: Object\n    :param path: 'attr1.attr2.etc'\n    :return: obj.attr1.attr2.etc\n    \"\"\"\n    attrs = path.split(\".\")\n\n    for attr in attrs:\n        if isinstance(obj, CaseInsensitiveDict):\n            obj = obj[attr]\n            continue\n\n        obj = getattr(obj, attr)\n\n    return obj\n</code></pre>"},{"location":"inputs/thredds/#stac_generator.plugins.inputs.thredds.ThreddsInput.run","title":"<code>run()</code>","text":"<p>Plugin's entrypoint.</p> Source code in <code>stac_generator/plugins/inputs/thredds.py</code> <pre><code>def run(self):\n    \"\"\"\n    Plugin's entrypoint.\n\n    \"\"\"\n    total_generated = 0\n    start = datetime.now()\n\n    catalog = TDSCatalog(self.conf.url, **self.conf.thredds_kwargs)\n\n    for _, dataset in self.walk_tds(catalog=catalog, depth=self.conf.depth):\n        output = {\"uri\": self.get_sub_attr(dataset, self.conf.uri_term)}\n\n        for extra_term in self.conf.extra_terms:\n            output[extra_term.output_key] = self.get_sub_attr(dataset, extra_term.key)\n\n        yield output\n        total_generated += 1\n\n    end = datetime.now()\n    print(f\"Processed {total_generated} records from {self.conf.url} in {end - start}\")\n</code></pre>"},{"location":"inputs/thredds/#stac_generator.plugins.inputs.thredds.ThreddsInput.walk_tds","title":"<code>walk_tds(catalog, depth)</code>","text":"<p>Return a generator walking a THREDDS data catalog for datasets.</p> <p>:param cat: THREDDS catalog. :param depth: Maximum recursive depth.</p> Source code in <code>stac_generator/plugins/inputs/thredds.py</code> <pre><code>def walk_tds(self, catalog: TDSCatalog, depth: int) -&gt; Iterator:\n    \"\"\"\n    Return a generator walking a THREDDS data catalog for datasets.\n\n    :param cat: THREDDS catalog.\n    :param depth: Maximum recursive depth.\n    \"\"\"\n    yield from catalog.datasets.items()\n\n    if depth &gt; 0:\n        for _, ref in catalog.catalog_refs.items():\n            child = ref.follow()\n            yield from self.walk_tds(catalog=child, depth=depth - 1)\n</code></pre>"},{"location":"mappings/jinja2/","title":"Jinja2","text":""},{"location":"mappings/jinja2/#stac_generator.plugins.mappings.jinja2.Jinja2Conf","title":"<code>Jinja2Conf</code>","text":"<p>               Bases: <code>BaseModel</code></p> <p>JINJA2 config model.</p> <p>Parameters:</p> Name Type Description Default <code>template_directory</code> <code>str</code> <p>Template directory.</p> required <code>template</code> <code>str</code> <p>JINJA template.</p> required Source code in <code>stac_generator/plugins/mappings/jinja2.py</code> <pre><code>class Jinja2Conf(BaseModel):\n    \"\"\"JINJA2 config model.\"\"\"\n\n    template_directory: str = Field(\n        description=\"Template directory.\",\n    )\n    template: str = Field(\n        description=\"JINJA template.\",\n    )\n</code></pre>"},{"location":"mappings/jinja2/#stac_generator.plugins.mappings.jinja2.Jinja2Mapping","title":"<code>Jinja2Mapping</code>","text":"<p>               Bases: <code>BaseMapping</code></p> <p>Render extracted metadata into Jinja template.</p> <p>Plugin name: <code>jinja2_mapping</code></p> Example Configuration <p>.. code-block:: yaml</p> <pre><code>- name: jinja2_mapping\n  conf:\n    template_directory: /path/to/template/directory\n    template: template_name\n</code></pre> Source code in <code>stac_generator/plugins/mappings/jinja2.py</code> <pre><code>class Jinja2Mapping(BaseMapping):\n    \"\"\"Render extracted metadata into Jinja template.\n\n    **Plugin name:** ``jinja2_mapping``\n\n    Example Configuration:\n        .. code-block:: yaml\n\n            - name: jinja2_mapping\n              conf:\n                template_directory: /path/to/template/directory\n                template: template_name\n\n    \"\"\"\n\n    config_class = Jinja2Conf\n\n    def run(\n        self,\n        body: dict,\n        recipe: Recipe,\n        **kwargs,\n    ) -&gt; dict:\n        environment = Environment(loader=FileSystemLoader(self.conf.template_directory))\n        template = environment.get_template(self.conf.template)\n\n        return template.render(**body)\n</code></pre>"},{"location":"mappings/stac/","title":"Stac","text":""},{"location":"mappings/stac/#stac_generator.plugins.mappings.stac.STACConf","title":"<code>STACConf</code>","text":"<p>               Bases: <code>BaseModel</code></p> <p>STAC mapping config model.</p> <p>Parameters:</p> Name Type Description Default <code>stac_root_url</code> <code>str</code> <p>STAC root URL.</p> required <code>stac_version</code> <code>str</code> <p>STAC version.</p> required <code>stac_extensions</code> <code>list[str]</code> <p>STAC extensions.</p> <code>[]</code> Source code in <code>stac_generator/plugins/mappings/stac.py</code> <pre><code>class STACConf(BaseModel):\n    \"\"\"STAC mapping config model.\"\"\"\n\n    stac_root_url: str = Field(\n        description=\"STAC root URL.\",\n    )\n    stac_version: str = Field(\n        description=\"STAC version.\",\n    )\n    stac_extensions: list[str] = Field(\n        default=[],\n        description=\"STAC extensions.\",\n    )\n</code></pre>"},{"location":"mappings/stac/#stac_generator.plugins.mappings.stac.STACMapping","title":"<code>STACMapping</code>","text":"<p>               Bases: <code>BaseMapping</code></p> <p>Map metadata into STAC.</p> <p>Mapping Name**: <code>stac_mapping</code></p> <p>Description:</p> <p>Example Configuration:</p> <pre><code>.. code-block:: yaml\n\n    - name: stac_mapping\n      conf:\n        stac_root_url: http://stac.catalog\n        stac_version: 0.0.1\n</code></pre> Source code in <code>stac_generator/plugins/mappings/stac.py</code> <pre><code>class STACMapping(BaseMapping):\n    \"\"\"Map metadata into STAC.\n\n    Mapping Name**: ``stac_mapping``\n\n    Description:\n\n\n    Example Configuration:\n\n        .. code-block:: yaml\n\n            - name: stac_mapping\n              conf:\n                stac_root_url: http://stac.catalog\n                stac_version: 0.0.1\n\n    \"\"\"\n\n    config_class = STACConf\n\n    def datetime_field(self, date_str: str) -&gt; str:\n        dt = parser.parse(date_str)\n        return dt.strftime(\"%Y-%m-%dT%H:%M:%SZ\")\n\n    def item(self, body: dict) -&gt; dict:\n        output = {\n            \"type\": \"Feature\",\n            \"stac_version\": self.conf.stac_version,\n            \"stac_extensions\": body.pop(\"stac_extensions\", []) + self.conf.stac_extensions,\n            \"id\": body.pop(\"id\"),\n            \"collection\": body.pop(\"collection\"),\n            \"geometry\": body.pop(\"geometry\", None),\n            \"assets\": body.pop(\"assets\", {}),\n            \"properties\": {\n                \"datetime\": None,\n            },\n        }\n\n        if \"datetime\" in body:\n            output[\"properties\"][\"datetime\"] = self.datetime_field(body.pop(\"datetime\"))\n\n        if \"start_datetime\" in body:\n            output[\"properties\"][\"start_datetime\"] = self.datetime_field(body.pop(\"start_datetime\"))\n\n        if \"end_datetime\" in body:\n            output[\"properties\"][\"end_datetime\"] = self.datetime_field(body.pop(\"end_datetime\"))\n\n        if \"bbox\" in body:\n            output[\"bbox\"] = body.pop(\"bbox\")\n\n        output[\"links\"] = body.pop(\"links\", []) + [\n            {\n                \"rel\": \"self\",\n                \"type\": \"application/geo+json\",\n                \"href\": f\"{self.conf.stac_root_url}/collections/{output['collection']}/items/{output['id']}\",\n            },\n            {\n                \"rel\": \"parent\",\n                \"type\": \"application/json\",\n                \"href\": f\"{self.conf.stac_root_url}/collections/{output['collection']}\",\n            },\n            {\n                \"rel\": \"collection\",\n                \"type\": \"application/json\",\n                \"href\": f\"{self.conf.stac_root_url}/collections/{output['collection']}\",\n            },\n            {\n                \"rel\": \"root\",\n                \"type\": \"application/json\",\n                \"href\": self.conf.stac_root_url,\n            },\n        ]\n\n        output[\"properties\"] |= body\n\n        return output\n\n    def collection(self, body: dict) -&gt; dict:\n        output = {\n            \"type\": \"Collection\",\n            \"stac_version\": self.conf.stac_version,\n            \"stac_extensions\": self.conf.stac_extensions,\n            \"id\": body.pop(\"id\"),\n            \"extent\": {\n                \"temporal\": {\n                    \"interval\": None,\n                },\n                \"spatial\": {\n                    \"bbox\": None,\n                },\n            },\n            \"summaries\": {},\n            \"assets\": {},\n            \"providers\": [],\n            \"license\": \"\",\n        }\n\n        if \"description\" in body:\n            output[\"description\"] = body.pop(\"description\")\n\n        if \"interval\" in body:\n            output[\"extent\"][\"temporal\"][\"interval\"] = body.pop(\"interval\")\n\n        if \"bbox\" in body:\n            output[\"extent\"][\"spatial\"][\"bbox\"] = body.pop(\"bbox\")\n\n        if \"license\" in body:\n            output[\"license\"] = body.pop(\"license\")\n\n        if \"providers\" in body:\n            output[\"providers\"] = body.pop(\"providers\")\n\n        if \"member_of_recipes\" in body:\n            output[\"member_of_recipes\"] = body.pop(\"member_of_recipes\")\n\n        output[\"summaries\"] |= body\n\n        output[\"links\"] = [\n            {\n                \"rel\": \"self\",\n                \"type\": \"application/geo+json\",\n                \"href\": f\"{self.conf.stac_root_url}/collections/{output['id']}\",\n            },\n            {\n                \"rel\": \"parent\",\n                \"type\": \"application/json\",\n                \"href\": f\"{self.conf.stac_root_url}/\",\n            },\n            {\n                \"rel\": \"queryables\",\n                \"type\": \"application/json\",\n                \"href\": f\"{self.conf.stac_root_url}/collections/{output['id']}/queryables\",\n            },\n            {\n                \"rel\": \"items\",\n                \"type\": \"application/geo+json\",\n                \"href\": f\"{self.conf.stac_root_url}/collections/cmip6/{output['id']}\",\n            },\n            {\n                \"rel\": \"root\",\n                \"type\": \"application/json\",\n                \"href\": self.conf.stac_root_url,\n            },\n        ]\n\n        return output\n\n    def run(\n        self,\n        body: dict,\n        recipe: Recipe,\n        **kwargs,\n    ) -&gt; dict:\n        if kwargs[\"GENERATOR_TYPE\"] == \"item\":\n            return self.item(body)\n\n        if kwargs[\"GENERATOR_TYPE\"] == \"collection\":\n            return self.collection(body)\n\n        return body\n</code></pre>"},{"location":"outputs/elasticsearch/","title":"Elasticsearch","text":""},{"location":"outputs/elasticsearch/#stac_generator.plugins.outputs.elasticsearch.ElasticsearchConf","title":"<code>ElasticsearchConf</code>","text":"<p>               Bases: <code>BaseModel</code></p> <p>Elasticsearch config model.</p> Source code in <code>stac_generator/plugins/outputs/elasticsearch.py</code> <pre><code>class ElasticsearchConf(BaseModel):\n    \"\"\"Elasticsearch config model.\"\"\"\n\n    index: ElasticsearchIndex = Field(\n        description=\"Elasticsearch index to post to.\",\n    )\n    client_kwargs: dict = Field(\n        default={},\n        description=\"Elasticsearch connection kwargs.\",\n    )\n    request_timeout: int = Field(\n        default=60,\n        description=\"Request timeout for search.\",\n    )\n</code></pre>"},{"location":"outputs/elasticsearch/#stac_generator.plugins.outputs.elasticsearch.ElasticsearchIndex","title":"<code>ElasticsearchIndex</code>","text":"<p>               Bases: <code>BaseModel</code></p> <p>Elasticsearch index model.</p> Source code in <code>stac_generator/plugins/outputs/elasticsearch.py</code> <pre><code>class ElasticsearchIndex(BaseModel):\n    \"\"\"Elasticsearch index model.\"\"\"\n\n    name: str = Field(\n        description=\"Name of index.\",\n    )\n    mapping: str | dict = Field(\n        default={},\n        description=\"Index initial mapping.\",\n    )\n</code></pre>"},{"location":"outputs/elasticsearch/#stac_generator.plugins.outputs.elasticsearch.ElasticsearchOutput","title":"<code>ElasticsearchOutput</code>","text":"<p>               Bases: <code>Output</code></p> <p>Output generated meta data to elasticsearch.</p> <p>Plugin name: <code>elasticsearch</code></p> Example Configuration <p>.. code-block:: yaml</p> <pre><code>- name: elasticsearch\n    conf:\n      client_kwargs:\n        hosts: ['host1','host2']\n      index:\n        name: 'assets-2021-06-02'\n</code></pre> Source code in <code>stac_generator/plugins/outputs/elasticsearch.py</code> <pre><code>class ElasticsearchOutput(Output):\n    \"\"\"\n    Output generated meta data to elasticsearch.\n\n    **Plugin name:** ``elasticsearch``\n\n    Example Configuration:\n        .. code-block:: yaml\n\n            - name: elasticsearch\n                conf:\n                  client_kwargs:\n                    hosts: ['host1','host2']\n                  index:\n                    name: 'assets-2021-06-02'\n    \"\"\"\n\n    config_class = ElasticsearchConf\n\n    def __init__(self, **kwargs):\n        super().__init__(**kwargs)\n\n        self.es = Elasticsearch(**self.conf.client_kwargs)\n\n        # Create the index, if it doesn't already exist\n        if mapping := self.conf.index.mapping:\n            if not self.es.indices.exists(self.conf.index.name):\n                if isinstance(mapping, str):\n                    mapping = load_yaml(mapping)\n                self.es.indices.create(self.conf.index.name, body=mapping)\n\n    def export(self, data: dict, **kwargs) -&gt; None:\n\n        self.es.update(\n            index=self.conf.index.name,\n            id=data[\"id\"],\n            body={\"doc\": data, \"doc_as_upsert\": True},\n            request_timeout=self.conf.request_timeout,\n        )\n</code></pre>"},{"location":"outputs/intake_esm/","title":"Intake esm","text":""},{"location":"outputs/intake_esm/#stac_generator.plugins.outputs.intake_esm.ElasticsearchConf","title":"<code>ElasticsearchConf</code>","text":"<p>               Bases: <code>BaseModel</code></p> <p>IntakeESM config model.</p> <p>Parameters:</p> Name Type Description Default <code>filepath</code> <code>str</code> <p>Elasticsearch index to post to.</p> required <code>namespace</code> <code>str</code> <p>Elasticsearch index to post to.</p> <code>'asset'</code> <code>collection</code> <code>str</code> <p>Term to use for the JSON file name.</p> <code>'collection'</code> <code>description</code> <code>str</code> <p>Term to use for the JSON file name.</p> <code>''</code> Source code in <code>stac_generator/plugins/outputs/intake_esm.py</code> <pre><code>class ElasticsearchConf(BaseModel):\n    \"\"\"IntakeESM config model.\"\"\"\n\n    filepath: str = Field(\n        description=\"Elasticsearch index to post to.\",\n    )\n    namespace: str = Field(\n        default=\"asset\",\n        description=\"Elasticsearch index to post to.\",\n    )\n    collection: str = Field(\n        default=\"collection\",\n        description=\"Term to use for the JSON file name.\",\n    )\n    description: str = Field(\n        default=\"\",\n        description=\"Term to use for the JSON file name.\",\n    )\n</code></pre>"},{"location":"outputs/intake_esm/#stac_generator.plugins.outputs.intake_esm.IntakeESMOutput","title":"<code>IntakeESMOutput</code>","text":"<p>               Bases: <code>Output</code></p> <p>Outputs to a Intake ESM catalog description and a zipped CSV file at a location of your choosing.</p> <p>This is only to be used for testing purposes and not suitable for large scale application.</p> <p>Note also that the CSV header is constructed from the first data payload processed. If there are attribute variations across files, attribute columns may not align, which will yield an invalid catalog.</p> <p>Plugin name: <code>intake_esm_out</code></p> Example Configuration <p>.. code-block:: yaml</p> <pre><code>- name: intake_esm_out\n  conf:\n    filepath: location/to/destination_files/\n    collection: my_collection\n    description: A long form description of the dataset catalog.\n</code></pre> Source code in <code>stac_generator/plugins/outputs/intake_esm.py</code> <pre><code>class IntakeESMOutput(Output):\n    \"\"\"\n    Outputs to a Intake ESM catalog description and a zipped CSV file\n    at a location of your choosing.\n\n    This is only to be used for testing purposes and not suitable for large\n    scale application.\n\n    Note also that the CSV header is constructed from the first data payload processed. If there are attribute variations\n    across files, attribute columns may not align, which will yield an invalid catalog.\n\n    **Plugin name:** ``intake_esm_out``\n\n    Example Configuration:\n        .. code-block:: yaml\n\n            - name: intake_esm_out\n              conf:\n                filepath: location/to/destination_files/\n                collection: my_collection\n                description: A long form description of the dataset catalog.\n\n    \"\"\"\n\n    def __init__(self, **kwargs):\n        super().__init__(**kwargs)\n\n        if os.path.isdir(self.conf.filepath):\n            self.filepath = os.path.join(self.conf.filepath, self.conf.collection)\n\n        self.json_path = self.filepath + \".json\"\n        self.csv_path = self.filepath + \".csv.gz\"\n\n    @staticmethod\n    def properties(data):\n        \"\"\"Return list of property names.\n\n        Note that results may vary from one item to the next.\n        \"\"\"\n        return list(data[\"body\"][\"properties\"].keys())\n\n    @staticmethod\n    def data2row(data):\n        \"\"\"Return list of property values.\"\"\"\n        return list(data[\"body\"][\"properties\"].values())\n\n    def to_intake_spec(self, data):\n        \"\"\"Return Intake specification file content.\"\"\"\n\n        attributes = [{\"column_name\": key} for key in self.properties(data)]\n        ext = data[\"body\"][\"extension\"]\n\n        spec = {\n            \"esmcat_version\": ESMCAT_VERSION,\n            \"id\": self.conf.namespace,\n            \"description\": self.conf.description,\n            \"catalog_file\": self.csv_path,\n            \"attributes\": attributes,\n            \"assets\": {\"column_name\": \"path\", \"format\": ASSET_FORMAT[ext]},\n        }\n        return spec\n\n    def export(self, data: dict, **kwargs) -&gt; None:\n        \"\"\"Write data to disk.\"\"\"\n        import csv\n        import gzip\n\n        if not os.path.exists(self.json_path):\n            # Create catalog spec file and CSV file with header and first data row\n\n            # Write ESM-Collection json file\n            with open(self.json_path, mode=\"wt\") as f:\n                json.dump(self.to_intake_spec(data), f)\n\n            # Write catalog data in csv.gz format\n            with gzip.open(filename=self.csv_path, mode=\"wt\") as f:\n                w = csv.writer(f)\n                w.writerow(self.properties(data))\n                w.writerow(self.data2row(data))\n\n        else:\n            # Append new data row to CSV file\n            with gzip.open(filename=self.csv_path, mode=\"at\") as f:\n                w = csv.writer(f)\n                w.writerow(self.data2row(data))\n</code></pre>"},{"location":"outputs/intake_esm/#stac_generator.plugins.outputs.intake_esm.IntakeESMOutput.data2row","title":"<code>data2row(data)</code>  <code>staticmethod</code>","text":"<p>Return list of property values.</p> Source code in <code>stac_generator/plugins/outputs/intake_esm.py</code> <pre><code>@staticmethod\ndef data2row(data):\n    \"\"\"Return list of property values.\"\"\"\n    return list(data[\"body\"][\"properties\"].values())\n</code></pre>"},{"location":"outputs/intake_esm/#stac_generator.plugins.outputs.intake_esm.IntakeESMOutput.export","title":"<code>export(data, **kwargs)</code>","text":"<p>Write data to disk.</p> Source code in <code>stac_generator/plugins/outputs/intake_esm.py</code> <pre><code>def export(self, data: dict, **kwargs) -&gt; None:\n    \"\"\"Write data to disk.\"\"\"\n    import csv\n    import gzip\n\n    if not os.path.exists(self.json_path):\n        # Create catalog spec file and CSV file with header and first data row\n\n        # Write ESM-Collection json file\n        with open(self.json_path, mode=\"wt\") as f:\n            json.dump(self.to_intake_spec(data), f)\n\n        # Write catalog data in csv.gz format\n        with gzip.open(filename=self.csv_path, mode=\"wt\") as f:\n            w = csv.writer(f)\n            w.writerow(self.properties(data))\n            w.writerow(self.data2row(data))\n\n    else:\n        # Append new data row to CSV file\n        with gzip.open(filename=self.csv_path, mode=\"at\") as f:\n            w = csv.writer(f)\n            w.writerow(self.data2row(data))\n</code></pre>"},{"location":"outputs/intake_esm/#stac_generator.plugins.outputs.intake_esm.IntakeESMOutput.properties","title":"<code>properties(data)</code>  <code>staticmethod</code>","text":"<p>Return list of property names.</p> <p>Note that results may vary from one item to the next.</p> Source code in <code>stac_generator/plugins/outputs/intake_esm.py</code> <pre><code>@staticmethod\ndef properties(data):\n    \"\"\"Return list of property names.\n\n    Note that results may vary from one item to the next.\n    \"\"\"\n    return list(data[\"body\"][\"properties\"].keys())\n</code></pre>"},{"location":"outputs/intake_esm/#stac_generator.plugins.outputs.intake_esm.IntakeESMOutput.to_intake_spec","title":"<code>to_intake_spec(data)</code>","text":"<p>Return Intake specification file content.</p> Source code in <code>stac_generator/plugins/outputs/intake_esm.py</code> <pre><code>def to_intake_spec(self, data):\n    \"\"\"Return Intake specification file content.\"\"\"\n\n    attributes = [{\"column_name\": key} for key in self.properties(data)]\n    ext = data[\"body\"][\"extension\"]\n\n    spec = {\n        \"esmcat_version\": ESMCAT_VERSION,\n        \"id\": self.conf.namespace,\n        \"description\": self.conf.description,\n        \"catalog_file\": self.csv_path,\n        \"attributes\": attributes,\n        \"assets\": {\"column_name\": \"path\", \"format\": ASSET_FORMAT[ext]},\n    }\n    return spec\n</code></pre>"},{"location":"outputs/json_file/","title":"Json file","text":""},{"location":"outputs/json_file/#stac_generator.plugins.outputs.json_file.JsonFileConf","title":"<code>JsonFileConf</code>","text":"<p>               Bases: <code>BaseModel</code></p> <p>JSON config model.</p> <p>Parameters:</p> Name Type Description Default <code>filename</code> <code>str</code> <p>Term to use for the JSON file name.</p> <code>'$id'</code> <code>dirpath</code> <code>str</code> <p>Root directory for JSON files.</p> required Source code in <code>stac_generator/plugins/outputs/json_file.py</code> <pre><code>class JsonFileConf(BaseModel):\n    \"\"\"JSON config model.\"\"\"\n\n    filename: str = Field(\n        default=\"$id\",\n        description=\"Term to use for the JSON file name.\",\n    )\n    dirpath: str = Field(\n        description=\"Root directory for JSON files.\",\n    )\n</code></pre>"},{"location":"outputs/json_file/#stac_generator.plugins.outputs.json_file.JsonFileOutput","title":"<code>JsonFileOutput</code>","text":"<p>               Bases: <code>Output</code></p> <p>Output to a JSON file.</p> <p>Plugin name: <code>json_out</code></p> Example Configuration <p>.. code-block:: yaml</p> <pre><code>- name: json_out\n  conf:\n    dirpath: location_to_destination_file\n    filename_term: item_id\n</code></pre> Source code in <code>stac_generator/plugins/outputs/json_file.py</code> <pre><code>class JsonFileOutput(Output):\n    \"\"\"\n    Output to a JSON file.\n\n    **Plugin name:** ``json_out``\n\n    Example Configuration:\n        .. code-block:: yaml\n\n            - name: json_out\n              conf:\n                dirpath: location_to_destination_file\n                filename_term: item_id\n    \"\"\"\n\n    config_class = JsonFileConf\n\n    def export(self, data: dict, **kwargs) -&gt; None:\n        filename = f\"{data[self.conf.filename].strip('/').replace('/', '.')}.json\"\n        filepath = os.path.join(self.conf.dirpath, filename)\n\n        with open(filepath, \"w+\", encoding=\"utf-8\") as file:\n            json.dump(data, file, indent=4)\n</code></pre>"},{"location":"outputs/rabbit_mq/","title":"Rabbit mq","text":""},{"location":"outputs/rabbit_mq/#stac_generator.plugins.outputs.rabbit_mq.RabbitMQConf","title":"<code>RabbitMQConf</code>","text":"<p>               Bases: <code>BaseModel</code></p> <p>RabbitMQ config model.</p> <p>Parameters:</p> Name Type Description Default <code>connection</code> <code>RabbitMQConnection</code> <p>RabbitMQ connection kwargs.</p> required <code>exchange</code> <code>RabbitMQExchange</code> <p>RabbitMQ exchange info.</p> required Source code in <code>stac_generator/plugins/outputs/rabbit_mq.py</code> <pre><code>class RabbitMQConf(BaseModel):\n    \"\"\"RabbitMQ config model.\"\"\"\n\n    connection: RabbitMQConnection = Field(\n        description=\"RabbitMQ connection kwargs.\",\n    )\n    exchange: RabbitMQExchange = Field(\n        description=\"RabbitMQ exchange info.\",\n    )\n</code></pre>"},{"location":"outputs/rabbit_mq/#stac_generator.plugins.outputs.rabbit_mq.RabbitMQConnection","title":"<code>RabbitMQConnection</code>","text":"<p>               Bases: <code>BaseModel</code></p> <p>JSON config model.</p> <p>Parameters:</p> Name Type Description Default <code>user</code> <code>str</code> <p>RabbitMQ user.</p> required <code>password</code> <code>str</code> <p>RabbitMQ password.</p> required <code>host</code> <code>str</code> <p>RabbitMQ host.</p> required <code>vhost</code> <code>str</code> <p>RabbitMQ vhost.</p> required <code>kwargs</code> <code>dict</code> <p>RabbitMQ additional kwargs.</p> <code>{}</code> Source code in <code>stac_generator/plugins/outputs/rabbit_mq.py</code> <pre><code>class RabbitMQConnection(BaseModel):\n    \"\"\"JSON config model.\"\"\"\n\n    user: str = Field(\n        description=\"RabbitMQ user.\",\n    )\n    password: str = Field(\n        description=\"RabbitMQ password.\",\n    )\n    host: str = Field(\n        description=\"RabbitMQ host.\",\n    )\n    vhost: str = Field(\n        description=\"RabbitMQ vhost.\",\n    )\n    kwargs: dict = Field(\n        default={},\n        description=\"RabbitMQ additional kwargs.\",\n    )\n</code></pre>"},{"location":"outputs/rabbit_mq/#stac_generator.plugins.outputs.rabbit_mq.RabbitMQExchange","title":"<code>RabbitMQExchange</code>","text":"<p>               Bases: <code>BaseModel</code></p> <p>JSON config model.</p> <p>Parameters:</p> Name Type Description Default <code>name</code> <code>str</code> <p>RabbitMQ exchange name.</p> required <code>type</code> <code>str</code> <p>RabbitMQ exchange type.</p> required <code>routing_key</code> <code>str</code> <p>RabbitMQ exchange routing key.</p> <code>''</code> Source code in <code>stac_generator/plugins/outputs/rabbit_mq.py</code> <pre><code>class RabbitMQExchange(BaseModel):\n    \"\"\"JSON config model.\"\"\"\n\n    name: str = Field(\n        description=\"RabbitMQ exchange name.\",\n    )\n    type: str = Field(\n        description=\"RabbitMQ exchange type.\",\n    )\n    routing_key: str = Field(\n        default=\"\",\n        description=\"RabbitMQ exchange routing key.\",\n    )\n</code></pre>"},{"location":"outputs/rabbit_mq/#stac_generator.plugins.outputs.rabbit_mq.RabbitMQOutput","title":"<code>RabbitMQOutput</code>","text":"<p>               Bases: <code>Output</code></p> <p>Output to a <code>RabbitMQ Queue &lt;https://www.rabbitmq.com/&gt;</code>_.</p> <p>Plugin name: <code>rabbitmq_out</code></p> Example Configuration <p>.. code-block:: yaml</p> <pre><code>- name: rabbitmq\n  conf:\n    connection:\n      host: my-rabbit-server.co.uk\n      user: user\n      password: '*********'\n      vhost: my_virtual_host\n      kwargs:\n        heartbeat: 300\n    exchange:\n      name: mydest-exchange\n      type: fanout\n      routing_key: asset\n</code></pre> Source code in <code>stac_generator/plugins/outputs/rabbit_mq.py</code> <pre><code>class RabbitMQOutput(Output):\n    \"\"\"\n    Output to a `RabbitMQ Queue &lt;https://www.rabbitmq.com/&gt;`_.\n\n    **Plugin name:** ``rabbitmq_out``\n\n    Example Configuration:\n        .. code-block:: yaml\n\n            - name: rabbitmq\n              conf:\n                connection:\n                  host: my-rabbit-server.co.uk\n                  user: user\n                  password: '*********'\n                  vhost: my_virtual_host\n                  kwargs:\n                    heartbeat: 300\n                exchange:\n                  name: mydest-exchange\n                  type: fanout\n                  routing_key: asset\n    \"\"\"\n\n    config_class = RabbitMQConf\n\n    def __init__(self, **kwargs):\n        super().__init__(**kwargs)\n\n        # Create the credentials object\n        credentials = pika.PlainCredentials(\n            self.conf.connection.user, self.conf.connection.password\n        )\n\n        # Start the rabbitMQ connection\n        rabbit_connection = pika.BlockingConnection(\n            pika.ConnectionParameters(\n                host=self.conf.connection.host,\n                credentials=credentials,\n                virtual_host=self.conf.connection.vhost,\n                **self.conf.connection.kwargs,\n            )\n        )\n\n        # Create a new channel\n        self.channel = rabbit_connection.channel()\n        self.channel.exchange_declare(\n            exchange=self.conf.exchange.name,\n            exchange_type=self.conf.exchange.type,\n        )\n\n    def export(self, data: dict, **kwargs) -&gt; None:\n        \"\"\"\n        Export the data to rabbit.\n\n        :param data: expected data as header dict\n        \"\"\"\n\n        message = {\n            f\"{data['surtype'].value}_id\": data[f\"{data['surtype'].value}_id\"],\n            \"uri\": data[\"uri\"],\n        }\n\n        self.channel.basic_publish(\n            exchange=self.conf.exchange.name,\n            body=json.dumps(message),\n            routing_key=self.conf.exchange.routing_key,\n        )\n</code></pre>"},{"location":"outputs/rabbit_mq/#stac_generator.plugins.outputs.rabbit_mq.RabbitMQOutput.export","title":"<code>export(data, **kwargs)</code>","text":"<p>Export the data to rabbit.</p> <p>:param data: expected data as header dict</p> Source code in <code>stac_generator/plugins/outputs/rabbit_mq.py</code> <pre><code>def export(self, data: dict, **kwargs) -&gt; None:\n    \"\"\"\n    Export the data to rabbit.\n\n    :param data: expected data as header dict\n    \"\"\"\n\n    message = {\n        f\"{data['surtype'].value}_id\": data[f\"{data['surtype'].value}_id\"],\n        \"uri\": data[\"uri\"],\n    }\n\n    self.channel.basic_publish(\n        exchange=self.conf.exchange.name,\n        body=json.dumps(message),\n        routing_key=self.conf.exchange.routing_key,\n    )\n</code></pre>"},{"location":"outputs/stac_fastapi/","title":"Stac fastapi","text":""},{"location":"outputs/stac_fastapi/#stac_generator.plugins.outputs.stac_fastapi.AuthenticationFlow","title":"<code>AuthenticationFlow</code>","text":"<p>               Bases: <code>BaseModel</code></p> <p>STAC authentication model.</p> <p>Parameters:</p> Name Type Description Default <code>flow</code> <code>Literal['client_credentials', 'authorization_code']</code> <p>Flow to use.</p> required <code>token_url</code> <code>str</code> <p>Token URL for authentication server.</p> required <code>client_id</code> <code>str</code> <p>Client id.</p> required <code>client_secret</code> <code>str</code> <p>Client secret.</p> required <code>kwargs</code> <code>dict[str, Any]</code> <p>Extra kwargs for Authentication.</p> <code>{}</code> Source code in <code>stac_generator/plugins/outputs/stac_fastapi.py</code> <pre><code>class AuthenticationFlow(BaseModel):\n    \"\"\"STAC authentication model.\"\"\"\n\n    flow: Literal[\"client_credentials\", \"authorization_code\"] = Field(\n        description=\"Flow to use.\",\n    )\n    token_url: str = Field(\n        description=\"Token URL for authentication server.\",\n    )\n    client_id: str = Field(\n        description=\"Client id.\",\n    )\n    client_secret: str = Field(\n        description=\"Client secret.\",\n    )\n    kwargs: dict[str, Any] = Field(\n        default={},\n        description=\"Extra kwargs for Authentication.\",\n    )\n</code></pre>"},{"location":"outputs/stac_fastapi/#stac_generator.plugins.outputs.stac_fastapi.AuthorizationCode","title":"<code>AuthorizationCode</code>","text":"<p>               Bases: <code>AuthenticationFlow</code></p> <p>STAC Authorization Code model.</p> <p>Parameters:</p> Name Type Description Default <code>flow</code> <code>Literal['authorization_code']</code> <p>Flow to use.</p> required <code>authorization_url</code> <code>str</code> <p>Token URL for authentication server.</p> required Source code in <code>stac_generator/plugins/outputs/stac_fastapi.py</code> <pre><code>class AuthorizationCode(AuthenticationFlow):\n    \"\"\"STAC Authorization Code model.\"\"\"\n\n    flow: Literal[\"authorization_code\"] = Field(\n        description=\"Flow to use.\",\n    )\n    authorization_url: str = Field(\n        description=\"Token URL for authentication server.\",\n    )\n</code></pre>"},{"location":"outputs/stac_fastapi/#stac_generator.plugins.outputs.stac_fastapi.ClientCredentials","title":"<code>ClientCredentials</code>","text":"<p>               Bases: <code>AuthenticationFlow</code></p> <p>STAC Client Credentials model.</p> <p>Parameters:</p> Name Type Description Default <code>flow</code> <code>Literal['client_credentials']</code> <p>Flow to use.</p> required Source code in <code>stac_generator/plugins/outputs/stac_fastapi.py</code> <pre><code>class ClientCredentials(AuthenticationFlow):\n    \"\"\"STAC Client Credentials model.\"\"\"\n\n    flow: Literal[\"client_credentials\"] = Field(\n        description=\"Flow to use.\",\n    )\n</code></pre>"},{"location":"outputs/stac_fastapi/#stac_generator.plugins.outputs.stac_fastapi.STACFastAPIConf","title":"<code>STACFastAPIConf</code>","text":"<p>               Bases: <code>BaseModel</code></p> <p>STAC FastAPI config model.</p> <p>Parameters:</p> Name Type Description Default <code>api_url</code> <code>str</code> <p>URL for API.</p> required <code>authentication</code> <code>AuthorizationCode | ClientCredentials</code> <p>Authentication for STAC API.</p> <code>None</code> <code>headers</code> <code>dict</code> <p>Headers for API request.</p> <code>{}</code> <code>verify</code> <code>bool</code> <p>API certificate verifcation.</p> <code>False</code> Source code in <code>stac_generator/plugins/outputs/stac_fastapi.py</code> <pre><code>class STACFastAPIConf(BaseModel):\n    \"\"\"STAC FastAPI config model.\"\"\"\n\n    api_url: str = Field(\n        description=\"URL for API.\",\n    )\n    authentication: AuthorizationCode | ClientCredentials = Field(\n        default=None,\n        description=\"Authentication for STAC API.\",\n    )\n    headers: dict = Field(\n        default={},\n        description=\"Headers for API request.\",\n    )\n    verify: bool = Field(\n        default=False,\n        description=\"API certificate verifcation.\",\n    )\n</code></pre>"},{"location":"outputs/stac_fastapi/#stac_generator.plugins.outputs.stac_fastapi.STACFastAPIOutput","title":"<code>STACFastAPIOutput</code>","text":"<p>               Bases: <code>Output</code></p> <p>Output to a STAC FastAPI using the Transaction endpoint extension</p> <p>Plugin name: <code>stac_fastapi</code></p> Example Configuration <p>.. code-block:: yaml</p> <pre><code>- name: stac_fastapi\n  conf:\n    api_url: https://localhost\n</code></pre> Source code in <code>stac_generator/plugins/outputs/stac_fastapi.py</code> <pre><code>class STACFastAPIOutput(Output):\n    \"\"\"\n    Output to a STAC FastAPI using the Transaction endpoint extension\n\n    **Plugin name:** ``stac_fastapi``\n\n    Example Configuration:\n        .. code-block:: yaml\n\n            - name: stac_fastapi\n              conf:\n                api_url: https://localhost\n    \"\"\"\n\n    config_class = STACFastAPIConf\n\n    def item(\n        self,\n        data: dict,\n        client: Client,\n        auth: OAuth2AuthorizationCodePKCE | OAuth2ClientCredentials | None,\n    ) -&gt; None:\n\n        collection = data[\"collection\"]\n\n        response = client.post(\n            urljoin(self.conf.api_url, f\"collections/{collection}/items\"),\n            json=data,\n            auth=auth,\n            headers=self.conf.headers,\n        )\n\n        if response.status_code == 404:\n\n            response_json = response.json()\n\n            if response_json[\"description\"] == f\"Collection {collection} does not exist\":\n                collection_data = {\n                    \"type\": \"Collection\",\n                    \"id\": collection,\n                    \"description\": collection,\n                    \"stac_version\": \"0.1.0\",\n                    \"stac_extensions\": [],\n                    \"license\": data.get(\"license\", \"other\"),\n                    \"extent\": {\n                        \"spatial\": {\"bbox\": [[-180, -90, 180, 90]]},\n                        \"temporal\": {\n                            \"interval\": [[\"1992-01-01T00:00:00Z\", \"2015-12-31T00:00:00Z\"]]\n                        },\n                    },\n                    \"links\": data.get(\"links\", [])\n                    + [\n                        {\n                            \"rel\": \"self\",\n                            \"type\": \"application/geo+json\",\n                            \"href\": f\"{self.conf.api_url}/collections/{collection}\",\n                        },\n                        {\n                            \"rel\": \"parent\",\n                            \"type\": \"application/json\",\n                            \"href\": f\"{self.conf.api_url}/\",\n                        },\n                        {\n                            \"rel\": \"queryables\",\n                            \"type\": \"application/json\",\n                            \"href\": f\"{self.conf.api_url}/collections/{collection}/queryables\",\n                        },\n                        {\n                            \"rel\": \"items\",\n                            \"type\": \"application/geo+json\",\n                            \"href\": f\"{self.conf.api_url}/collections/cmip6/{collection}\",\n                        },\n                        {\n                            \"rel\": \"root\",\n                            \"type\": \"application/json\",\n                            \"href\": self.conf.api_url,\n                        },\n                    ],\n                }\n\n                response = client.post(\n                    urljoin(self.conf.api_url, \"collections\"),\n                    json=collection_data,\n                    auth=auth,\n                    headers=self.conf.headers,\n                )\n\n                response = client.post(\n                    urljoin(self.conf.api_url, f\"collections/{collection}/items\"),\n                    json=data,\n                    auth=auth,\n                    headers=self.conf.headers,\n                )\n\n        if response.status_code == 409:\n            response_json = response.json()\n\n            if (\n                response_json[\"description\"]\n                == f\"Item {data['id']} in collection {collection} already exists\"\n            ):\n                response = client.put(\n                    urljoin(self.conf.api_url, f\"collections/{collection}/items/{data['id']}\"),\n                    json=data,\n                    auth=auth,\n                )\n\n                if response.is_error:\n                    print(\n                        f\"FastAPI Output Item update failed with status code: {response.status_code} and response text: {response.text}\",\n                    )\n\n        elif response.is_error:\n            print(\n                f\"FastAPI Output failed to post to STAC Fastapi items endpoint returned status code: {response.status_code} and response text: {response.text} request data: {data}\",\n            )\n\n    def collection(self, data: dict, client: Client, auth: OAuth2ClientCredentials | None) -&gt; None:\n        response = client.post(urljoin(self.conf.api_url, \"collections\"), json=data, auth=auth)\n\n        if response.status_code == 409:\n            response_json = response.json()\n\n            if response_json[\"description\"] == f\"Collection {data['id']} already exists\":\n                response = client.put(\n                    urljoin(self.conf.api_url, \"collections\"),\n                    # urljoin(self.api_url, f\"collections/{data['id']}\"),\n                    json=data,\n                    auth=auth,\n                )\n\n                if response.is_error:\n                    LOGGER.warning(\n                        \"FastAPI Output Collection update failed with status code: %s and response text: %s\",\n                        response.status_code,\n                        response.text,\n                    )\n\n        elif response.is_error:\n            LOGGER.warning(\n                \"FastAPI Output failed to post to STAC Fastapi collections endpoint returned status code: %s and response text: %s request data: %s\",\n                response.status_code,\n                response.text,\n                data,\n            )\n\n    def export(self, data: dict, **kwargs) -&gt; None:\n        client = Client(\n            verify=self.conf.verify,\n            timeout=180,\n        )\n\n        auth = None\n        match self.conf.authentication:\n\n            case ClientCredentials():\n                auth = OAuth2ClientCredentials(\n                    token_url=self.conf.authentication.token_url,\n                    client_id=self.conf.authentication.client_id,\n                    client_secret=self.conf.authentication.client_secret,\n                    **self.conf.authentication.kwargs,\n                )\n\n            case AuthorizationCode():\n                auth = OAuth2AuthorizationCodePKCE(\n                    authorization_url=self.conf.authentication.authorization_url,\n                    token_url=self.conf.authentication.token_url,\n                    client_id=self.conf.authentication.client_id,\n                    client_secret=self.conf.authentication.client_secret,\n                    **self.conf.authentication.kwargs,\n                )\n\n        if kwargs[\"GENERATOR_TYPE\"] == \"item\":\n            self.item(data, client, auth)\n\n        elif kwargs[\"GENERATOR_TYPE\"] == \"collection\":\n            self.collection(data, client, auth)\n</code></pre>"},{"location":"outputs/standard_out/","title":"Standard out","text":""},{"location":"outputs/standard_out/#stac_generator.plugins.outputs.standard_out.StandardOutOutput","title":"<code>StandardOutOutput</code>","text":"<p>               Bases: <code>Output</code></p> <p>Output to standard out. Useful for testing and debugging.</p> <p>Plugin name: <code>standard_out</code></p> Example configuration <p>.. code-block:: yaml</p> <pre><code>- name: standard_out\n</code></pre> Source code in <code>stac_generator/plugins/outputs/standard_out.py</code> <pre><code>class StandardOutOutput(Output):\n    \"\"\"\n    Output to standard out.\n    Useful for testing and debugging.\n\n    **Plugin name:** ``standard_out``\n\n    Example configuration:\n        .. code-block:: yaml\n\n            - name: standard_out\n    \"\"\"\n\n    def export(self, data: dict, **kwargs) -&gt; None:\n        \"\"\"\n        Print the received data.\n\n        :param data: Data from extraction process\n        :param kwargs: Not used\n        \"\"\"\n        pp = pprint.PrettyPrinter(indent=4)\n        pp.pprint(data)\n</code></pre>"},{"location":"outputs/standard_out/#stac_generator.plugins.outputs.standard_out.StandardOutOutput.export","title":"<code>export(data, **kwargs)</code>","text":"<p>Print the received data.</p> <p>:param data: Data from extraction process :param kwargs: Not used</p> Source code in <code>stac_generator/plugins/outputs/standard_out.py</code> <pre><code>def export(self, data: dict, **kwargs) -&gt; None:\n    \"\"\"\n    Print the received data.\n\n    :param data: Data from extraction process\n    :param kwargs: Not used\n    \"\"\"\n    pp = pprint.PrettyPrinter(indent=4)\n    pp.pprint(data)\n</code></pre>"},{"location":"outputs/text_file/","title":"Text file","text":""},{"location":"outputs/text_file/#stac_generator.plugins.outputs.text_file.TextFileConf","title":"<code>TextFileConf</code>","text":"<p>               Bases: <code>BaseModel</code></p> <p>Text File config model.</p> <p>Parameters:</p> Name Type Description Default <code>filepath</code> <code>str</code> <p>Path to text file.</p> required Source code in <code>stac_generator/plugins/outputs/text_file.py</code> <pre><code>class TextFileConf(BaseModel):\n    \"\"\"Text File config model.\"\"\"\n\n    filepath: str = Field(\n        description=\"Path to text file.\",\n    )\n</code></pre>"},{"location":"outputs/text_file/#stac_generator.plugins.outputs.text_file.TextFileOutput","title":"<code>TextFileOutput</code>","text":"<p>               Bases: <code>Output</code></p> <p>Outputs to a text file.</p> <p>Plugin name: <code>file_out</code></p> Example Configuration <p>.. code-block:: yaml</p> <pre><code>- name: file_out\n  conf:\n    filepath: location_to_destination_file\n</code></pre> Source code in <code>stac_generator/plugins/outputs/text_file.py</code> <pre><code>class TextFileOutput(Output):\n    \"\"\"\n    Outputs to a text file.\n\n    **Plugin name:** ``file_out``\n\n    Example Configuration:\n        .. code-block:: yaml\n\n            - name: file_out\n              conf:\n                filepath: location_to_destination_file\n    \"\"\"\n\n    config_class = TextFileConf\n\n    def export(self, data: dict, **kwargs) -&gt; None:\n\n        if os.path.isdir(self.conf.filepath):\n            self.conf.filepath = os.path.join(self.conf.filepath, \"file_out.txt\")\n\n        with open(self.conf.filepat, \"a\", encoding=\"utf-8\") as file:\n            file.write(f\"{data}\\n\")\n</code></pre>"}]}